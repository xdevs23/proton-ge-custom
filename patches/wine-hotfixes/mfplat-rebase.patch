From a52b4686050becac47da71b266a1f7017738e3a7 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Tue, 9 Mar 2021 16:53:09 -0500
Subject: [PATCH 01/40] winegstreamer: Activate source pad in push mode if it
 isn't activated in pull mode.

Since our source pad is not part of any element, gstreamer won't end up activating it
directly through the state transition.  Instead, if the downstream element doesn't
activate the source pad into pull mode during the transition to the READY state,
we activate our pad in push mode.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/wg_parser.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index f76ca903b80..ac9a399234a 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -58,7 +58,7 @@ struct wg_parser
     pthread_mutex_t mutex;
 
     pthread_cond_t init_cond;
-    bool no_more_pads, has_duration, error;
+    bool no_more_pads, has_duration, error, pull_mode;
 
     pthread_cond_t read_cond, read_done_cond;
     struct
@@ -1331,9 +1331,12 @@ static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode
     GST_DEBUG("%s source pad for parser %p in %s mode.",
             activate ? "Activating" : "Deactivating", parser, gst_pad_mode_get_name(mode));
 
+    parser->pull_mode = false;
+
     switch (mode)
     {
         case GST_PAD_MODE_PULL:
+            parser->pull_mode = activate;
             return TRUE;
         case GST_PAD_MODE_PUSH:
             return activate_push(pad, activate);
@@ -1573,6 +1576,8 @@ static void CDECL wg_parser_disconnect(struct wg_parser *parser)
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 0);
     gst_pad_unlink(parser->my_src, parser->their_sink);
     gst_object_unref(parser->my_src);
     gst_object_unref(parser->their_sink);
@@ -1628,6 +1633,8 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     }
 
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
@@ -1679,6 +1686,8 @@ static BOOL avi_parser_init_gst(struct wg_parser *parser)
     }
 
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
@@ -1733,6 +1742,8 @@ static BOOL mpeg_audio_parser_init_gst(struct wg_parser *parser)
 
     gst_pad_set_active(stream->my_sink, 1);
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
@@ -1787,6 +1798,8 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
 
     gst_pad_set_active(stream->my_sink, 1);
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
-- 
2.30.2

From 07b959ae60e8d404a25754b31c5aec0230c9ebb2 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 10 Mar 2021 10:43:03 -0500
Subject: [PATCH 02/40] winegstreamer: Push stream-start and segment events in
 push mode.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/wg_parser.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index ac9a399234a..4bc4246a9e3 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1252,6 +1252,7 @@ static void *push_data(void *arg)
 {
     struct wg_parser *parser = arg;
     GstBuffer *buffer;
+    GstSegment *segment;
     guint max_size;
 
     GST_DEBUG("Starting push thread.");
@@ -1264,6 +1265,12 @@ static void *push_data(void *arg)
 
     max_size = parser->stop_offset ? parser->stop_offset : parser->file_size;
 
+    gst_pad_push_event(parser->my_src, gst_event_new_stream_start("wg_stream"));
+
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_BYTES);
+    gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+
     for (;;)
     {
         ULONG size;
@@ -1398,6 +1405,7 @@ static gboolean src_perform_seek(struct wg_parser *parser, GstEvent *event)
     GstEvent *flush_event;
     GstSeekFlags flags;
     gint64 cur, stop;
+    GstSegment *seg;
     guint32 seqnum;
     gdouble rate;
 
@@ -1431,7 +1439,12 @@ static gboolean src_perform_seek(struct wg_parser *parser, GstEvent *event)
         gst_event_set_seqnum(flush_event, seqnum);
         gst_pad_push_event(parser->my_src, flush_event);
         if (thread)
+        {
             gst_pad_set_active(parser->my_src, 1);
+            seg = gst_segment_new();
+            gst_segment_init(seg, GST_FORMAT_BYTES);
+            gst_pad_push_event(parser->my_src, gst_event_new_segment(seg));
+        }
     }
 
     return TRUE;
-- 
2.30.2

From 17be033828ca1edb3e4275a9a9fbf26027db8b9b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 10 Mar 2021 13:09:51 -0500
Subject: [PATCH 03/40] winegstreamer: Introduce H.264 decoder transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/decode_transform.c        | 301 +++++++++++++++++++
 dlls/winegstreamer/gst_private.h             |   2 +
 dlls/winegstreamer/main.c                    |   3 +
 dlls/winegstreamer/mfplat.c                  |   1 +
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 include/mfidl.idl                            |   1 +
 7 files changed, 315 insertions(+)
 create mode 100644 dlls/winegstreamer/decode_transform.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 4d5dece64b3..7459cccf7e4 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -8,6 +8,7 @@ EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	audioconvert.c \
+	decode_transform.c \
 	main.c \
 	media_source.c \
 	mfplat.c \
diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
new file mode 100644
index 00000000000..f5d4763bde4
--- /dev/null
+++ b/dlls/winegstreamer/decode_transform.c
@@ -0,0 +1,301 @@
+/* GStreamer Decoder Transform
+ *
+ * Copyright 2021 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct mf_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+};
+
+static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct mf_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI mf_decoder_QueryInterface (IMFTransform *iface, REFIID riid, void **out)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI mf_decoder_AddRef(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        heap_free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p %p %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("%p %u %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("%p %u %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p.\n", iface, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("%p, %u %lu.\n", iface, message, param);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl mf_decoder_vtbl =
+{
+    mf_decoder_QueryInterface,
+    mf_decoder_AddRef,
+    mf_decoder_Release,
+    mf_decoder_GetStreamLimits,
+    mf_decoder_GetStreamCount,
+    mf_decoder_GetStreamIDs,
+    mf_decoder_GetInputStreamInfo,
+    mf_decoder_GetOutputStreamInfo,
+    mf_decoder_GetAttributes,
+    mf_decoder_GetInputStreamAttributes,
+    mf_decoder_GetOutputStreamAttributes,
+    mf_decoder_DeleteInputStream,
+    mf_decoder_AddInputStreams,
+    mf_decoder_GetInputAvailableType,
+    mf_decoder_GetOutputAvailableType,
+    mf_decoder_SetInputType,
+    mf_decoder_SetOutputType,
+    mf_decoder_GetInputCurrentType,
+    mf_decoder_GetOutputCurrentType,
+    mf_decoder_GetInputStatus,
+    mf_decoder_GetOutputStatus,
+    mf_decoder_SetOutputBounds,
+    mf_decoder_ProcessEvent,
+    mf_decoder_ProcessMessage,
+    mf_decoder_ProcessInput,
+    mf_decoder_ProcessOutput,
+};
+
+HRESULT decode_transform_create(REFIID riid, void **obj)
+{
+    struct mf_decoder *object;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &mf_decoder_vtbl;
+    object->refcount = 1;
+
+    *obj = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 55a62361966..cdf90d52025 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -219,4 +219,6 @@ HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HI
 
 HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 
+HRESULT decode_transform_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
+
 #endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index d5c06bf3279..8ecd28e9f0e 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -319,6 +319,9 @@ HRESULT WINAPI DllRegisterServer(void)
 
     TRACE(".\n");
 
+    if (FAILED(hr = mfplat_DllRegisterServer()))
+        return hr;
+
     if (FAILED(hr = __wine_register_resources(winegstreamer_instance)))
         return hr;
 
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 68278838458..d03953ba7e4 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -412,6 +412,7 @@ class_objects[] =
     { &CLSID_VideoProcessorMFT, &video_processor_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
+    { &CLSID_CMSH264DecoderMFT, &decode_transform_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 072ec90eea4..064a6872c79 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -67,3 +67,9 @@ coclass GStreamerByteStreamHandler {}
     uuid(6a170414-aad9-4693-b806-3a0c47c570d6)
 ]
 coclass WINEAudioConverter { }
+
+[
+    threading(both),
+    uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
+]
+coclass CMSH264DecoderMFT { }
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 46c715a3752..63b2ab84c92 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -1412,3 +1412,4 @@ cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE, 0xba491365,
 cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, 0xba491366, 0xbe50, 0x451e, 0x95, 0xab, 0x6d, 0x4a, 0xcc, 0xc7, 0xda, 0xd8);")
 
 cpp_quote("EXTERN_GUID(CLSID_VideoProcessorMFT, 0x88753b26, 0x5b24, 0x49bd, 0xb2, 0xe7, 0xc, 0x44, 0x5c, 0x78, 0xc9, 0x82);")
+cpp_quote("EXTERN_GUID(CLSID_CMSH264DecoderMFT, 0x62ce7e72, 0x4c71, 0x4d20, 0xb1, 0x5d, 0x45, 0x28, 0x31, 0xa8, 0x7d, 0x9d);")
-- 
2.30.2

From e0872c463225f58e145bf4c2e57023f879dd11e2 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 10 Mar 2021 14:14:21 -0500
Subject: [PATCH 04/40] winegstreamer: Implement ::GetInputAvailableType for
 decode transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 60 +++++++++++++++++++++++++--
 dlls/winegstreamer/gst_private.h      |  6 ++-
 dlls/winegstreamer/mfplat.c           |  7 +++-
 3 files changed, 67 insertions(+), 6 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index f5d4763bde4..55a0c1c6c9b 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -29,10 +29,33 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+const GUID *h264_input_types[] = {&MFVideoFormat_H264};
+/* NV12 comes first https://docs.microsoft.com/en-us/windows/win32/medfound/mft-decoder-expose-output-types-in-native-order . thanks to @vitorhnn */
+const GUID *h264_output_types[] = {&MFVideoFormat_NV12, &MFVideoFormat_I420, &MFVideoFormat_IYUV, &MFVideoFormat_YUY2, &MFVideoFormat_YV12};
+
+static struct decoder_desc
+{
+    const GUID *major_type;
+    const GUID **input_types;
+    unsigned int input_types_count;
+    const GUID **output_types;
+    unsigned int output_types_count;
+} decoder_descs[] =
+{
+    { /* DECODER_TYPE_H264 */
+        &MFMediaType_Video,
+        h264_input_types,
+        ARRAY_SIZE(h264_input_types),
+        h264_output_types,
+        ARRAY_SIZE(h264_output_types),
+    },
+};
+
 struct mf_decoder
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
+    enum decoder_type type;
 };
 
 static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
@@ -163,9 +186,36 @@ static HRESULT WINAPI mf_decoder_AddInputStreams(IMFTransform *iface, DWORD stre
 static HRESULT WINAPI mf_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *input_type;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].input_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&input_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].input_types[index])))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    *type = input_type;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
@@ -284,11 +334,11 @@ static const IMFTransformVtbl mf_decoder_vtbl =
     mf_decoder_ProcessOutput,
 };
 
-HRESULT decode_transform_create(REFIID riid, void **obj)
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
 {
     struct mf_decoder *object;
 
-    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+    TRACE("%s, %p %u.\n", debugstr_guid(riid), obj, type);
 
     if (!(object = heap_alloc_zero(sizeof(*object))))
         return E_OUTOFMEMORY;
@@ -296,6 +346,8 @@ HRESULT decode_transform_create(REFIID riid, void **obj)
     object->IMFTransform_iface.lpVtbl = &mf_decoder_vtbl;
     object->refcount = 1;
 
+    object->type = type;
+
     *obj = &object->IMFTransform_iface;
     return S_OK;
 }
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index cdf90d52025..2d2ebbda61f 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -219,6 +219,10 @@ HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HI
 
 HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 
-HRESULT decode_transform_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
+enum decoder_type
+{
+    DECODER_TYPE_H264,
+};
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type) DECLSPEC_HIDDEN;
 
 #endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index d03953ba7e4..d3d5c3582d2 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -402,6 +402,11 @@ static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a
 
 static const GUID CLSID_WINEAudioConverter = {0x6a170414,0xaad9,0x4693,{0xb8,0x06,0x3a,0x0c,0x47,0xc5,0x70,0xd6}};
 
+static HRESULT h264_decoder_create(REFIID riid, void **ret)
+{
+    return decode_transform_create(riid, ret, DECODER_TYPE_H264);
+}
+
 static const struct class_object
 {
     const GUID *clsid;
@@ -412,7 +417,7 @@ class_objects[] =
     { &CLSID_VideoProcessorMFT, &video_processor_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
-    { &CLSID_CMSH264DecoderMFT, &decode_transform_create },
+    { &CLSID_CMSH264DecoderMFT, &h264_decoder_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
-- 
2.30.2

From 30fa73cd863d1ab90070727535247f251ee26638 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 10 Mar 2021 14:23:09 -0500
Subject: [PATCH 05/40] winegstreamer: Implement ::GetOutputAvailableType for
 decode transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 31 +++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index 55a0c1c6c9b..3c71fddd67c 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -221,9 +221,36 @@ static HRESULT WINAPI mf_decoder_GetInputAvailableType(IMFTransform *iface, DWOR
 static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *output_type;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].output_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].output_types[index])))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    *type = output_type;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
-- 
2.30.2

From d613594fa7d0d2172614ff722641aeaf55c700b2 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 11 Mar 2021 12:33:02 -0500
Subject: [PATCH 06/40] winegstreamer: Implement ::SetInputType for decode
 transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 80 ++++++++++++++++++++++++++-
 dlls/winegstreamer/gst_private.h      | 10 ++++
 dlls/winegstreamer/mfplat.c           | 17 +++++-
 dlls/winegstreamer/quartz_parser.c    |  1 +
 dlls/winegstreamer/wg_parser.c        | 76 +++++++++++++++++++++++++
 5 files changed, 180 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index 3c71fddd67c..f709ef32fc1 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -56,6 +56,8 @@ struct mf_decoder
     IMFTransform IMFTransform_iface;
     LONG refcount;
     enum decoder_type type;
+    IMFMediaType *input_type;
+    CRITICAL_SECTION cs;
 };
 
 static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
@@ -99,6 +101,14 @@ static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
 
     if (!refcount)
     {
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        DeleteCriticalSection(&decoder->cs);
+
         heap_free(decoder);
     }
 
@@ -255,9 +265,73 @@ static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWO
 
 static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format input_format;
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].input_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].input_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].input_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &input_format);
+    if (!input_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (!decoder->input_type)
+        hr = MFCreateMediaType(&decoder->input_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->input_type)))
+    {
+        IMFMediaType_Release(decoder->input_type);
+        decoder->input_type = NULL;
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
 }
 
 static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
@@ -375,6 +449,8 @@ HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
 
     object->type = type;
 
+    InitializeCriticalSection(&object->cs);
+
     *obj = &object->IMFTransform_iface;
     return S_OK;
 }
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 2d2ebbda61f..215cf4577d4 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -97,9 +97,19 @@ struct wg_format
                 WG_VIDEO_FORMAT_YVYU,
 
                 WG_VIDEO_FORMAT_CINEPAK,
+
+                WG_VIDEO_FORMAT_H264,
             } format;
             uint32_t width, height;
             uint32_t fps_n, fps_d;
+            union
+            {
+                struct
+                {
+                    uint32_t profile;
+                    uint32_t level;
+                } h264;
+            } compressed;
         } video;
         struct
         {
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index d3d5c3582d2..48733d8e205 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -532,6 +532,7 @@ video_formats[] =
     {&MFVideoFormat_YUY2,   WG_VIDEO_FORMAT_YUY2},
     {&MFVideoFormat_YV12,   WG_VIDEO_FORMAT_YV12},
     {&MFVideoFormat_YVYU,   WG_VIDEO_FORMAT_YVYU},
+    {&MFVideoFormat_H264,   WG_VIDEO_FORMAT_H264},
 };
 
 static const struct
@@ -715,10 +716,22 @@ static void mf_media_type_to_wg_format_video(IMFMediaType *type, struct wg_forma
         if (IsEqualGUID(&subtype, video_formats[i].subtype))
         {
             format->u.video.format = video_formats[i].format;
-            return;
+            break;
         }
     }
-    FIXME("Unrecognized video subtype %s.\n", debugstr_guid(&subtype));
+    if (i == ARRAY_SIZE(video_formats))
+        FIXME("Unrecognized video subtype %s.\n", debugstr_guid(&subtype));
+
+    if (format->u.video.format == WG_VIDEO_FORMAT_H264)
+    {
+        UINT32 profile, level;
+
+        if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_PROFILE, &profile)))
+            format->u.video.compressed.h264.profile = profile;
+
+        if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_LEVEL, &level)))
+            format->u.video.compressed.h264.level = level;
+    }
 }
 
 void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index e9e7c3a0f9f..656f465884b 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -270,6 +270,7 @@ static unsigned int get_image_size(const struct wg_format *format)
             return width * height * 3;
 
         case WG_VIDEO_FORMAT_UNKNOWN:
+        case WG_VIDEO_FORMAT_H264:
             break;
     }
 
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 4bc4246a9e3..9e8754390a1 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -381,6 +381,22 @@ static void wg_channel_mask_to_gst(GstAudioChannelPosition *positions, uint32_t
     }
 }
 
+static void wg_set_caps_from_wg_format(GstCaps *caps, const struct wg_format *format)
+{
+    switch (format->major_type)
+    {
+        case WG_MAJOR_TYPE_VIDEO:
+        {
+            gst_caps_set_simple(caps, "width", G_TYPE_INT, format->u.video.width, NULL);
+            gst_caps_set_simple(caps, "height", G_TYPE_INT, format->u.video.height, NULL);
+            gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.video.fps_n, format->u.video.fps_d, NULL);
+            break;
+        }
+        default:
+            break;
+    }
+}
+
 static GstCaps *wg_format_to_caps_audio(const struct wg_format *format)
 {
     GstAudioChannelPosition positions[32];
@@ -422,6 +438,65 @@ static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
     unsigned int i;
     GstCaps *caps;
 
+    /* compressed types */
+
+    if (format->u.video.format == WG_VIDEO_FORMAT_H264)
+    {
+        const char *profile;
+        const char *level;
+
+        caps = gst_caps_new_empty_simple("video/x-h264");
+        wg_set_caps_from_wg_format(caps, format);
+
+        gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "byte-stream", NULL);
+        gst_caps_set_simple(caps, "alignment", G_TYPE_STRING, "au", NULL);
+
+        switch (format->u.video.compressed.h264.profile)
+        {
+            case /* eAVEncH264VProfile_Main */ 77:  profile = "main"; break;
+            case /* eAVEncH264VProfile_High */ 100: profile = "high"; break;
+            case /* eAVEncH264VProfile_444 */  244: profile = "high-4:4:4"; break;
+            default:
+                ERR("Unrecognized H.264 profile attribute %u\n", format->u.video.compressed.h264.profile);
+                /* fallthrough */
+            case 0: profile = NULL;
+        }
+
+        switch (format->u.video.compressed.h264.level)
+        {
+            case /* eAVEncH264VLevel1 */   10: level = "1";   break;
+            case /* eAVEncH264VLevel1_1 */ 11: level = "1.1"; break;
+            case /* eAVEncH264VLevel1_2 */ 12: level = "1.2"; break;
+            case /* eAVEncH264VLevel1_3 */ 13: level = "1.3"; break;
+            case /* eAVEncH264VLevel2 */   20: level = "2";   break;
+            case /* eAVEncH264VLevel2_1 */ 21: level = "2.1"; break;
+            case /* eAVEncH264VLevel2_2 */ 22: level = "2.2"; break;
+            case /* eAVEncH264VLevel3 */   30: level = "3";   break;
+            case /* eAVEncH264VLevel3_1 */ 31: level = "3.1"; break;
+            case /* eAVEncH264VLevel3_2 */ 32: level = "3.2"; break;
+            case /* eAVEncH264VLevel4 */   40: level = "4";   break;
+            case /* eAVEncH264VLevel4_1 */ 41: level = "4.1"; break;
+            case /* eAVEncH264VLevel4_2 */ 42: level = "4.2"; break;
+            case /* eAVEncH264VLevel5 */   50: level = "5";   break;
+            case /* eAVEncH264VLevel5_1 */ 51: level = "5.1"; break;
+            case /* eAVEncH264VLevel5_2 */ 52: level = "5.2"; break;
+            default:
+                ERR("Unrecognized H.264 level attribute %u\n", format->u.video.compressed.h264.level);
+                /* fallthrough */
+            case 0: level = NULL;
+        }
+
+        if (profile)
+            gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+
+        if (level)
+            gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+        return caps;
+    }
+
+    /* uncompressed types */
+
     if ((video_format = wg_video_format_to_gst(format->u.video.format)) == GST_VIDEO_FORMAT_UNKNOWN)
         return NULL;
 
@@ -581,6 +656,7 @@ static void CDECL wg_parser_stream_enable(struct wg_parser_stream *stream, const
             case WG_VIDEO_FORMAT_YVYU:
             case WG_VIDEO_FORMAT_UNKNOWN:
             case WG_VIDEO_FORMAT_CINEPAK:
+            case WG_VIDEO_FORMAT_H264:
                 gst_util_set_object_arg(G_OBJECT(stream->flip), "method", "none");
                 break;
         }
-- 
2.30.2

From d7bb5e8c56fff6cf45c0697e53c840f19bc5759b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 11 Mar 2021 12:58:32 -0500
Subject: [PATCH 07/40] winegstreamer: Implement ::SetOutputType for decode
 transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 76 +++++++++++++++++++++++++--
 1 file changed, 73 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index f709ef32fc1..0848cb47c9d 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -56,7 +56,7 @@ struct mf_decoder
     IMFTransform IMFTransform_iface;
     LONG refcount;
     enum decoder_type type;
-    IMFMediaType *input_type;
+    IMFMediaType *input_type, *output_type;
     CRITICAL_SECTION cs;
 };
 
@@ -107,6 +107,12 @@ static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
             decoder->input_type = NULL;
         }
 
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
         DeleteCriticalSection(&decoder->cs);
 
         heap_free(decoder);
@@ -336,9 +342,73 @@ static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMF
 
 static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format output_format;
+    GUID major_type, subtype;
+    HRESULT hr;
+    unsigned int i;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].output_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].output_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].output_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &output_format);
+    if (!output_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (!decoder->output_type)
+        hr = MFCreateMediaType(&decoder->output_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->output_type)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
 }
 
 static HRESULT WINAPI mf_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
-- 
2.30.2

From 055b053f721f2f7fd711d00d4e6d7d4c2eb9bd0c Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 11 Mar 2021 14:40:32 -0500
Subject: [PATCH 08/40] winegstreamer: Implement ::Get(Input/Output)StreamInfo
 for decode transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 61 +++++++++++++++++++++++++--
 1 file changed, 57 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index 0848cb47c9d..dadd161bcc9 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -58,6 +58,7 @@ struct mf_decoder
     enum decoder_type type;
     IMFMediaType *input_type, *output_type;
     CRITICAL_SECTION cs;
+    BOOL video;
 };
 
 static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
@@ -150,16 +151,67 @@ static HRESULT WINAPI mf_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_s
 
 static HRESULT WINAPI mf_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+    /* TODO: retrieve following fields from gstreamer */
+    info->hnsMaxLatency = 0;
+    info->cbMaxLookahead = 0;
+    return S_OK;
 }
 
 static HRESULT WINAPI mf_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO stream_info = {};
+    GUID output_subtype;
+    UINT64 framesize;
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->video)
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER |
+                              MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 0;
+        if (SUCCEEDED(IMFMediaType_GetGUID(decoder->output_type, &MF_MT_SUBTYPE, &output_subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&output_subtype, framesize >> 32, (UINT32) framesize, &stream_info.cbSize);
+        }
+        if (!stream_info.cbSize)
+            ERR("Failed to get desired output buffer size\n");
+    }
+    else
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 4;
+    }
+    stream_info.cbAlignment = 0;
+
+    LeaveCriticalSection(&decoder->cs);
+
+    *info = stream_info;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI mf_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
@@ -518,6 +570,7 @@ HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
     object->refcount = 1;
 
     object->type = type;
+    object->video = decoder_descs[type].major_type == &MFMediaType_Video;
 
     InitializeCriticalSection(&object->cs);
 
-- 
2.30.2

From 53b2efd9f7031339020e64168e6250903734060e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:40:46 -0400
Subject: [PATCH 09/40] winegstreamer: Add push-mode path for wg_parser.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/gst_private.h   |  28 +-
 dlls/winegstreamer/media_source.c  |   4 +-
 dlls/winegstreamer/quartz_parser.c |   4 +-
 dlls/winegstreamer/wg_parser.c     | 426 +++++++++++++++++++++++++----
 4 files changed, 408 insertions(+), 54 deletions(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 215cf4577d4..25694aae84d 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -136,6 +136,14 @@ struct wg_format
     } u;
 };
 
+struct wg_rect
+{
+    uint32_t left;
+    uint32_t right;
+    uint32_t top;
+    uint32_t bottom;
+};
+
 enum wg_parser_event_type
 {
     WG_PARSER_EVENT_NONE = 0,
@@ -165,6 +173,14 @@ struct wg_parser_event
 };
 C_ASSERT(sizeof(struct wg_parser_event) == 40);
 
+enum wg_read_result
+{
+    WG_READ_SUCCESS,
+    WG_READ_FAILURE,
+    WG_READ_FLUSHING,
+    WG_READ_EOS,
+};
+
 struct unix_funcs
 {
     struct wg_parser *(CDECL *wg_decodebin_parser_create)(void);
@@ -174,6 +190,8 @@ struct unix_funcs
     void (CDECL *wg_parser_destroy)(struct wg_parser *parser);
 
     HRESULT (CDECL *wg_parser_connect)(struct wg_parser *parser, uint64_t file_size);
+    HRESULT (CDECL *wg_parser_connect_unseekable)(struct wg_parser *parser,
+            const struct wg_format *in_format, uint32_t stream_count, const struct wg_format *out_formats, const struct wg_rect *apertures);
     void (CDECL *wg_parser_disconnect)(struct wg_parser *parser);
 
     void (CDECL *wg_parser_begin_flush)(struct wg_parser *parser);
@@ -181,7 +199,11 @@ struct unix_funcs
 
     bool (CDECL *wg_parser_get_read_request)(struct wg_parser *parser,
             void **data, uint64_t *offset, uint32_t *size);
-    void (CDECL *wg_parser_complete_read_request)(struct wg_parser *parser, bool ret);
+    /* bytes_available indicates the actual size of the input packet, or 0 if the source source pad isn't aware of packets.
+       If this value is lower or equal to the requested buffer size, it signifies the number of valid bytes set, if this
+       value is higher than the requested buffer size, it means that a push mode pad should query for the rest of packet,
+       concatenate the result, then submit it downstream. */
+    void (CDECL *wg_parser_complete_read_request)(struct wg_parser *parser, enum wg_read_result ret, uint32_t bytes_available);
 
     void (CDECL *wg_parser_set_unlimited_buffering)(struct wg_parser *parser);
 
@@ -189,7 +211,7 @@ struct unix_funcs
     struct wg_parser_stream *(CDECL *wg_parser_get_stream)(struct wg_parser *parser, uint32_t index);
 
     void (CDECL *wg_parser_stream_get_preferred_format)(struct wg_parser_stream *stream, struct wg_format *format);
-    void (CDECL *wg_parser_stream_enable)(struct wg_parser_stream *stream, const struct wg_format *format);
+    void (CDECL *wg_parser_stream_enable)(struct wg_parser_stream *stream, const struct wg_format *format, const struct wg_rect *aperture);
     void (CDECL *wg_parser_stream_disable)(struct wg_parser_stream *stream);
 
     bool (CDECL *wg_parser_stream_get_event)(struct wg_parser_stream *stream, struct wg_parser_event *event);
@@ -204,6 +226,8 @@ struct unix_funcs
     /* start_pos and stop_pos are in 100-nanosecond units. */
     bool (CDECL *wg_parser_stream_seek)(struct wg_parser_stream *stream, double rate,
             uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags);
+    /* true: The stream has fully drained or has been flushed. false: An event is available. */
+    bool (CDECL *wg_parser_stream_drain)(struct wg_parser_stream *stream);
 };
 
 extern const struct unix_funcs *unix_funcs;
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 3260175f45a..331c87dc371 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -282,7 +282,7 @@ static void start_pipeline(struct media_source *source, struct source_async_comm
             IMFMediaTypeHandler_GetCurrentMediaType(mth, &current_mt);
 
             mf_media_type_to_wg_format(current_mt, &format);
-            unix_funcs->wg_parser_stream_enable(stream->wg_stream, &format);
+            unix_funcs->wg_parser_stream_enable(stream->wg_stream, &format, NULL);
 
             IMFMediaType_Release(current_mt);
             IMFMediaTypeHandler_Release(mth);
@@ -527,7 +527,7 @@ static DWORD CALLBACK read_thread(void *arg)
             hr = IMFByteStream_Read(byte_stream, data, size, &ret_size);
         if (SUCCEEDED(hr) && ret_size != size)
             ERR("Unexpected short read: requested %u bytes, got %u.\n", size, ret_size);
-        unix_funcs->wg_parser_complete_read_request(source->wg_parser, SUCCEEDED(hr));
+        unix_funcs->wg_parser_complete_read_request(source->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, ret_size);
     }
 
     TRACE("Media source is shutting down; exiting.\n");
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 656f465884b..ac6e76856ca 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -801,7 +801,7 @@ static DWORD CALLBACK read_thread(void *arg)
         if (!unix_funcs->wg_parser_get_read_request(filter->wg_parser, &data, &offset, &size))
             continue;
         hr = IAsyncReader_SyncRead(filter->reader, offset, size, data);
-        unix_funcs->wg_parser_complete_read_request(filter->wg_parser, SUCCEEDED(hr));
+        unix_funcs->wg_parser_complete_read_request(filter->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, size);
     }
 
     TRACE("Streaming stopped; exiting.\n");
@@ -1449,7 +1449,7 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
 
     ret = amt_to_wg_format(&pin->pin.pin.mt, &format);
     assert(ret);
-    unix_funcs->wg_parser_stream_enable(pin->wg_stream, &format);
+    unix_funcs->wg_parser_stream_enable(pin->wg_stream, &format, NULL);
 
     /* We do need to drop any buffers that might have been sent with the old
      * caps, but this will be handled in parser_init_stream(). */
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 9e8754390a1..3a691589e53 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -44,7 +44,7 @@ struct wg_parser
     BOOL (*init_gst)(struct wg_parser *parser);
 
     struct wg_parser_stream **streams;
-    unsigned int stream_count;
+    unsigned int stream_count, expected_stream_count;
 
     GstElement *container, *decodebin;
     GstBus *bus;
@@ -58,7 +58,7 @@ struct wg_parser
     pthread_mutex_t mutex;
 
     pthread_cond_t init_cond;
-    bool no_more_pads, has_duration, error, pull_mode;
+    bool no_more_pads, has_duration, error, pull_mode, seekable;
 
     pthread_cond_t read_cond, read_done_cond;
     struct
@@ -67,10 +67,12 @@ struct wg_parser
         uint64_t offset;
         uint32_t size;
         bool done;
-        bool ret;
+        enum wg_read_result ret;
     } read_request;
 
-    bool flushing, sink_connected;
+    bool flushing, sink_connected, draining;
+
+    struct wg_format input_format;
 };
 
 struct wg_parser_stream
@@ -80,9 +80,10 @@ struct wg_parser_stream
     struct wg_parser *parser;
 
     GstPad *their_src, *post_sink, *post_src, *my_sink;
-    GstElement *flip;
+    GstElement *flip, *box;
     GstSegment segment;
     struct wg_format preferred_format, current_format;
+    struct wg_rect aperture;
 
     pthread_cond_t event_cond, event_empty_cond;
     struct wg_parser_event event;
@@ -568,6 +571,9 @@ static void CDECL wg_parser_begin_flush(struct wg_parser *parser)
 {
     unsigned int i;
 
+    if (!parser->seekable)
+        return;
+
     pthread_mutex_lock(&parser->mutex);
     parser->flushing = true;
     pthread_mutex_unlock(&parser->mutex);
@@ -581,6 +587,9 @@ static void CDECL wg_parser_begin_flush(struct wg_parser *parser)
 
 static void CDECL wg_parser_end_flush(struct wg_parser *parser)
 {
+    if (!parser->seekable)
+        return;
+
     pthread_mutex_lock(&parser->mutex);
     parser->flushing = false;
     pthread_mutex_unlock(&parser->mutex);
@@ -591,7 +600,7 @@ static bool CDECL wg_parser_get_read_request(struct wg_parser *parser,
 {
     pthread_mutex_lock(&parser->mutex);
 
-    while (parser->sink_connected && !parser->read_request.data)
+    while (parser->sink_connected && (!parser->read_request.data || parser->read_request.done))
         pthread_cond_wait(&parser->read_cond, &parser->mutex);
 
     if (!parser->sink_connected)
@@ -608,14 +617,25 @@ static bool CDECL wg_parser_get_read_request(struct wg_parser *parser,
     return true;
 }
 
-static void CDECL wg_parser_complete_read_request(struct wg_parser *parser, bool ret)
+static void CDECL wg_parser_complete_read_request(struct wg_parser *parser, enum wg_read_result ret, uint32_t bytes_available)
 {
     pthread_mutex_lock(&parser->mutex);
-    parser->read_request.done = true;
     parser->read_request.ret = ret;
-    parser->read_request.data = NULL;
-    pthread_mutex_unlock(&parser->mutex);
+    if (ret == WG_READ_SUCCESS && bytes_available < parser->read_request.size)
+    {
+        parser->read_request.offset += bytes_available;
+        parser->read_request.size -= bytes_available;
+        parser->read_request.data = (unsigned char *)parser->read_request.data + bytes_available;
+    }
+    else
+    {
+        parser->read_request.data = NULL;
+        /* reuse size parameter to indicate how many more bytes are left to write */
+        parser->read_request.size = bytes_available;
+    }
+    parser->read_request.done = true;
     pthread_cond_signal(&parser->read_done_cond);
+    pthread_mutex_unlock(&parser->mutex);
 }
 
 static void CDECL wg_parser_set_unlimited_buffering(struct wg_parser *parser)
@@ -627,11 +647,15 @@ static void CDECL wg_parser_set_unlimited_buffering(struct wg_parser *parser)
 
 static void CDECL wg_parser_stream_get_preferred_format(struct wg_parser_stream *stream, struct wg_format *format)
 {
-    *format = stream->preferred_format;
+    if (stream->has_caps)
+        *format = stream->preferred_format;
 }
 
-static void CDECL wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format)
+static void CDECL wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format, const struct wg_rect *aperture)
 {
+    if (!stream->parser->seekable)
+        return;
+
     stream->current_format = *format;
     stream->enabled = true;
 
@@ -660,6 +684,18 @@ static void CDECL wg_parser_stream_enable(struct wg_parser_stream *stream, const
                 gst_util_set_object_arg(G_OBJECT(stream->flip), "method", "none");
                 break;
         }
+
+        if (aperture)
+        {
+            if (aperture->left)
+                g_object_set(G_OBJECT(stream->box), "left", -aperture->left, NULL);
+            if (aperture->top)
+                g_object_set(G_OBJECT(stream->box), "top", -aperture->top, NULL);
+            if (aperture->right)
+                g_object_set(G_OBJECT(stream->box), "right", aperture->right - format->u.video.width, NULL);
+            if (aperture->bottom)
+                g_object_set(G_OBJECT(stream->box), "bottom", aperture->bottom - format->u.video.height, NULL);
+        }
     }
 
     gst_pad_push_event(stream->my_sink, gst_event_new_reconfigure());
@@ -688,6 +724,11 @@ static bool CDECL wg_parser_stream_get_event(struct wg_parser_stream *stream, st
 
     *event = stream->event;
 
+    /* Set to ensure that drain isn't called on an EOS stream, causing a lock-up
+       due to pull_data never being called again */
+    if (stream->event.type == WG_PARSER_EVENT_EOS)
+        stream->eos = true;
+
     if (stream->event.type != WG_PARSER_EVENT_BUFFER)
     {
         stream->event.type = WG_PARSER_EVENT_NONE;
@@ -748,6 +789,9 @@ static bool CDECL wg_parser_stream_seek(struct wg_parser_stream *stream, double
     GstSeekType start_type = GST_SEEK_TYPE_SET, stop_type = GST_SEEK_TYPE_SET;
     GstSeekFlags flags = 0;
 
+    if (!stream->parser->seekable)
+        return false;
+
     if (start_flags & AM_SEEKING_SeekToKeyFrame)
         flags |= GST_SEEK_FLAG_KEY_UNIT;
     if (start_flags & AM_SEEKING_Segment)
@@ -764,6 +808,43 @@ static bool CDECL wg_parser_stream_seek(struct wg_parser_stream *stream, double
             GST_FORMAT_TIME, flags, start_type, start_pos * 100, stop_type, stop_pos * 100));
 }
 
+static bool CDECL wg_parser_stream_drain(struct wg_parser_stream *stream)
+{
+    struct wg_parser *parser = stream->parser;
+    bool ret;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    /* Sanity check making sure caller didn't try to drain an already-EOS or unselected stream.
+       There's no reason for a caller to do this, but it could be an accident in which case we
+       should indicate that the stream is drained instead of locking-up. */
+    if (!stream->enabled || stream->eos)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return true;
+    }
+
+    parser->draining = true;
+    pthread_cond_signal(&parser->read_done_cond);
+
+    /* We must wait for either an event to occur or the drain to complete.
+       Since drains are blocking, we assign this responsibility to the thread
+       pulling data, as the pipeline will not need to pull more data until
+       the drain completes.  If one input buffer yields more than one output
+       buffer, the chain callback blocks on the wg_parser_stream_buffer_release
+       for the first buffer, which would never be called if the drain function
+       hadn't completed. */
+    while (!parser->flushing && parser->draining && stream->event.type == WG_PARSER_EVENT_NONE)
+        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+
+    ret = stream->event.type == WG_PARSER_EVENT_NONE;
+    parser->draining = false;
+
+    pthread_mutex_unlock(&stream->parser->mutex);
+
+    return ret;
+}
+
 static void CDECL wg_parser_stream_notify_qos(struct wg_parser_stream *stream,
         bool underflow, double proportion, int64_t diff, uint64_t timestamp)
 {
@@ -1039,14 +1120,27 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 static struct wg_parser_stream *create_stream(struct wg_parser *parser)
 {
     struct wg_parser_stream *stream, **new_array;
+    unsigned int i;
     char pad_name[19];
 
-    if (!(new_array = realloc(parser->streams, (parser->stream_count + 1) * sizeof(*parser->streams))))
-        return NULL;
-    parser->streams = new_array;
+    for (i = 0; i < parser->expected_stream_count; i++)
+    {
+        if (!parser->streams[i]->parser)
+        {
+            stream = parser->streams[i];
+            break;
+        }
+    }
 
-    if (!(stream = calloc(1, sizeof(*stream))))
-        return NULL;
+    if (i == parser->expected_stream_count)
+    {
+        if (!(new_array = realloc(parser->streams, (parser->stream_count + 1) * sizeof(*parser->streams))))
+            return NULL;
+        parser->streams = new_array;
+
+        if (!(stream = calloc(1, sizeof(*stream))))
+            return NULL;
+    }
 
     stream->parser = parser;
     pthread_cond_init(&stream->event_cond, NULL);
@@ -1084,7 +1178,7 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
 
     if (!strcmp(name, "video/x-raw"))
     {
-        GstElement *deinterlace, *vconv, *flip, *vconv2;
+        GstElement *deinterlace, *vconv, *flip, *videobox, *vconv2;
 
         /* DirectShow can express interlaced video, but downstream filters can't
          * necessarily consume it. In particular, the video renderer can't. */
@@ -1113,6 +1207,13 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
             goto out;
         }
 
+        if (!(videobox = gst_element_factory_make("videobox", NULL)))
+        {
+            fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+            goto out;
+        }
+
         /* videoflip does not support 15 and 16-bit RGB so add a second videoconvert
          * to do the final conversion. */
         if (!(vconv2 = gst_element_factory_make("videoconvert", NULL)))
@@ -1122,6 +1223,18 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
             goto out;
         }
 
+        if (!parser->seekable)
+        {
+            if (stream->aperture.left)
+                g_object_set(G_OBJECT(videobox), "left", -stream->aperture.left, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(videobox), "top", -stream->aperture.top, NULL);
+            if (stream->aperture.right)
+                g_object_set(G_OBJECT(videobox), "right", stream->aperture.right - stream->current_format.u.video.width, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(videobox), "bottom", stream->aperture.bottom - stream->current_format.u.video.height, NULL);
+        }
+
         /* The bin takes ownership of these elements. */
         gst_bin_add(GST_BIN(parser->container), deinterlace);
         gst_element_sync_state_with_parent(deinterlace);
@@ -1129,16 +1242,20 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
         gst_element_sync_state_with_parent(vconv);
         gst_bin_add(GST_BIN(parser->container), flip);
         gst_element_sync_state_with_parent(flip);
+        gst_bin_add(GST_BIN(parser->container), videobox);
+        gst_element_sync_state_with_parent(videobox);
         gst_bin_add(GST_BIN(parser->container), vconv2);
         gst_element_sync_state_with_parent(vconv2);
 
         gst_element_link(deinterlace, vconv);
         gst_element_link(vconv, flip);
-        gst_element_link(flip, vconv2);
+        gst_element_link(flip, videobox);
+        gst_element_link(videobox, vconv2);
 
         stream->post_sink = gst_element_get_static_pad(deinterlace, "sink");
         stream->post_src = gst_element_get_static_pad(vconv2, "src");
         stream->flip = flip;
+        stream->box = videobox;
     }
     else if (!strcmp(name, "audio/x-raw"))
     {
@@ -1226,23 +1343,25 @@ static void pad_removed_cb(GstElement *element, GstPad *pad, gpointer user)
     g_free(name);
 }
 
-static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
-        guint64 offset, guint size, GstBuffer **buffer)
+static GstFlowReturn pull_data(struct wg_parser *parser, guint64 offset, guint size, guint *size_read, GstBuffer **buffer)
 {
-    struct wg_parser *parser = gst_pad_get_element_private(pad);
     GstBuffer *new_buffer = NULL;
+    enum wg_read_result ret;
     GstMapInfo map_info;
-    bool ret;
+    unsigned int i;
 
-    GST_LOG("pad %p, offset %" G_GINT64_MODIFIER "u, length %u, buffer %p.", pad, offset, size, *buffer);
+    GST_LOG("pad %p, offset %" G_GINT64_MODIFIER "u, length %u, buffer %p.", parser->my_src, offset, size, *buffer);
 
     if (offset == GST_BUFFER_OFFSET_NONE)
         offset = parser->next_pull_offset;
     parser->next_pull_offset = offset + size;
-    if (offset >= parser->file_size)
-        return GST_FLOW_EOS;
-    if (offset + size >= parser->file_size)
-        size = parser->file_size - offset;
+    if (parser->seekable)
+    {
+        if (offset >= parser->file_size)
+            return GST_FLOW_EOS;
+        if (offset + size >= parser->file_size)
+            size = parser->file_size - offset;
+    }
 
     if (!*buffer)
         *buffer = new_buffer = gst_buffer_new_and_alloc(size);
@@ -1251,6 +1370,14 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
 
     pthread_mutex_lock(&parser->mutex);
 
+    if (parser->draining)
+    {
+        gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+        parser->draining = false;
+        for (i = 0; i < parser->stream_count; i++)
+            pthread_cond_signal(&parser->streams[i]->event_cond);
+    }
+
     assert(!parser->read_request.data);
     parser->read_request.data = map_info.data;
     parser->read_request.offset = offset;
@@ -1262,8 +1389,36 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
      * the upstream pin to flush if necessary. We should never be blocked on
      * read_thread() not running. */
 
-    while (!parser->read_request.done)
+    while (!parser->read_request.done && !parser->draining)
+    {
         pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+        if (parser->draining)
+        {
+            gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+            parser->draining = false;
+            for (i = 0; i < parser->stream_count; i++)
+                pthread_cond_signal(&parser->streams[i]->event_cond);
+        }
+        if (size != parser->read_request.size && parser->read_request.data)
+        {
+            if (size_read)
+            {
+                *size_read = size - parser->read_request.size;
+                parser->read_request.done = true;
+                break;
+            }
+            else
+            {
+                parser->read_request.done = false;
+                pthread_cond_signal(&parser->read_cond);
+            }
+        }
+    }
+
+    parser->read_request.data = NULL;
+
+    if (size_read && parser->read_request.size > size)
+        *size_read = parser->read_request.size;
 
     ret = parser->read_request.ret;
 
@@ -1271,12 +1426,29 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
 
     gst_buffer_unmap(*buffer, &map_info);
 
+    if (size_read)
+        size = min(*size_read, size);
+
+    gst_buffer_set_size(*buffer, size);
+
     GST_LOG("Request returned %d.", ret);
 
-    if (!ret && new_buffer)
+    if (ret != WG_READ_SUCCESS && new_buffer)
         gst_buffer_unref(new_buffer);
 
-    return ret ? GST_FLOW_OK : GST_FLOW_ERROR;
+    return ret == WG_READ_SUCCESS ? GST_FLOW_OK :
+           ret == WG_READ_FAILURE ? GST_FLOW_ERROR :
+           ret == WG_READ_FLUSHING ? GST_FLOW_FLUSHING :
+           ret == WG_READ_EOS ? GST_FLOW_EOS :
+           GST_FLOW_ERROR;
+}
+
+static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
+        guint64 offset, guint size, GstBuffer **buffer)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+
+    return pull_data(parser, offset, size, NULL, buffer);
 }
 
 static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
@@ -1295,7 +1467,7 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
                 gst_query_set_duration(query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
                 return TRUE;
             }
-            else if (format == GST_FORMAT_BYTES)
+            else if (format == GST_FORMAT_BYTES && parser->seekable)
             {
                 gst_query_set_duration(query, GST_FORMAT_BYTES, parser->file_size);
                 return TRUE;
@@ -1309,15 +1481,42 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
                 GST_WARNING("Cannot seek using format \"%s\".", gst_format_get_name(format));
                 return FALSE;
             }
+            if (!parser->seekable)
+                return FALSE;
             gst_query_set_seeking(query, GST_FORMAT_BYTES, 1, 0, parser->file_size);
             return TRUE;
 
         case GST_QUERY_SCHEDULING:
-            gst_query_set_scheduling(query, GST_SCHEDULING_FLAG_SEEKABLE, 1, -1, 0);
+            gst_query_set_scheduling(query, parser->seekable ? GST_SCHEDULING_FLAG_SEEKABLE : GST_SCHEDULING_FLAG_SEQUENTIAL, 1, -1, 0);
             gst_query_add_scheduling_mode(query, GST_PAD_MODE_PUSH);
             gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
             return TRUE;
 
+        case GST_QUERY_CAPS:
+        {
+            GstCaps *caps, *filter, *temp;
+
+            gst_query_parse_caps(query, &filter);
+
+            if (parser->input_format.major_type)
+                caps = wg_format_to_caps(&parser->input_format);
+            else
+                caps = gst_caps_new_any();
+            if (!caps)
+                return FALSE;
+
+            if (filter)
+            {
+                temp = gst_caps_intersect(caps, filter);
+                gst_caps_unref(caps);
+                caps = temp;
+            }
+
+            gst_query_set_caps_result(query, caps);
+            gst_caps_unref(caps);
+            return TRUE;
+        }
+
         default:
             GST_WARNING("Unhandled query type %s.", GST_QUERY_TYPE_NAME(query));
             return FALSE;
@@ -1327,42 +1526,115 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 static void *push_data(void *arg)
 {
     struct wg_parser *parser = arg;
-    GstBuffer *buffer;
+    GstBuffer *last_buffer = NULL;
+    ULONG alloc_size = 16384;
     GstSegment *segment;
     guint max_size;
 
     GST_DEBUG("Starting push thread.");
 
-    if (!(buffer = gst_buffer_new_allocate(NULL, 16384, NULL)))
-    {
-        GST_ERROR("Failed to allocate memory.");
-        return NULL;
-    }
-
     max_size = parser->stop_offset ? parser->stop_offset : parser->file_size;
 
     gst_pad_push_event(parser->my_src, gst_event_new_stream_start("wg_stream"));
 
+    if (parser->input_format.major_type)
+        gst_pad_push_event(parser->my_src, gst_event_new_caps(wg_format_to_caps(&parser->input_format)));
+
     segment = gst_segment_new();
     gst_segment_init(segment, GST_FORMAT_BYTES);
     gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
 
+    assert(!(GST_PAD_IS_FLUSHING(parser->my_src)));
+
     for (;;)
     {
+        GstBuffer *buffer = NULL;
+        unsigned int i;
         ULONG size;
         int ret;
 
         if (parser->next_offset >= max_size)
             break;
-        size = min(16384, max_size - parser->next_offset);
+        size = min(alloc_size, max_size - parser->next_offset);
 
-        if ((ret = src_getrange_cb(parser->my_src, NULL, parser->next_offset, size, &buffer)) < 0)
+        ret = pull_data(parser, parser->next_offset, size, &size, &buffer);
+
+        /* When we are in unseekable push mode, the pushing pad is responsible for handling flushing.  */
+        if (!parser->seekable && ret == GST_FLOW_FLUSHING)
         {
+            if (last_buffer)
+            {
+                gst_buffer_unref(last_buffer);
+                last_buffer = NULL;
+            }
+
+            gst_pad_push_event(parser->my_src, gst_event_new_seek(1.0f,
+                GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_NONE, 0, GST_SEEK_TYPE_NONE, 0));
+
+            continue;
+        }
+
+        if (!parser->seekable && ret == GST_FLOW_EOS)
+        {
+            if (last_buffer)
+            {
+                gst_buffer_unref(last_buffer);
+                last_buffer = NULL;
+            }
+
+            gst_pad_push_event(parser->my_src, gst_event_new_eos());
+            pthread_mutex_lock(&parser->mutex);
+            for (i = 0; i < parser->stream_count; i++)
+            {
+                if (!parser->streams[i]->enabled)
+                    continue;
+                while (!parser->streams[i]->flushing && !parser->streams[i]->eos)
+                    pthread_cond_wait(&parser->streams[i]->event_empty_cond, &parser->mutex);
+                parser->streams[i]->eos = false;
+            }
+
+            if (parser->flushing)
+            {
+                pthread_mutex_unlock(&parser->mutex);
+                continue;
+            }
+
+            pthread_mutex_unlock(&parser->mutex);
+
+            segment = gst_segment_new();
+            gst_segment_init(segment, GST_FORMAT_BYTES);
+            gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+
+            continue;
+        }
+
+        if (ret < 0)
+        {
+            if (last_buffer)
+            {
+                gst_buffer_unref(last_buffer);
+                last_buffer = NULL;
+            }
+
             GST_ERROR("Failed to read data, ret %s.", gst_flow_get_name(ret));
             break;
         }
 
-        parser->next_offset += size;
+        parser->next_offset += gst_buffer_get_size(buffer);
+
+        if (last_buffer)
+        {
+            buffer = gst_buffer_append(last_buffer, buffer);
+            last_buffer = NULL;
+            assert(alloc_size >= size);
+        }
+
+        if (size > gst_buffer_get_size(buffer))
+        {
+            last_buffer = buffer;
+            alloc_size = (size + 0xfff) & ~0xfff;
+            continue;
+        }
 
         buffer->duration = buffer->pts = -1;
         if ((ret = gst_pad_push(parser->my_src, buffer)) < 0)
@@ -1372,8 +1644,6 @@ static void *push_data(void *arg)
         }
     }
 
-    gst_buffer_unref(buffer);
-
     gst_pad_push_event(parser->my_src, gst_event_new_eos());
 
     GST_DEBUG("Stopping push thread.");
@@ -1389,6 +1659,12 @@ static gboolean activate_push(GstPad *pad, gboolean activate)
     {
         if (parser->push_thread)
         {
+            pthread_mutex_lock(&parser->mutex);
+            parser->read_request.ret = WG_READ_FAILURE;
+            parser->read_request.data = NULL;
+            parser->read_request.done = true;
+            pthread_mutex_unlock(&parser->mutex);
+            pthread_cond_signal(&parser->read_done_cond);
             pthread_join(parser->push_thread, NULL);
             parser->push_thread = 0;
         }
@@ -1574,13 +1850,11 @@ static LONGLONG query_duration(GstPad *pad)
     return 0;
 }
 
-static HRESULT CDECL wg_parser_connect(struct wg_parser *parser, uint64_t file_size)
+static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
 {
     GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("quartz_src",
             GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
-    unsigned int i;
 
-    parser->file_size = file_size;
     parser->sink_connected = true;
 
     if (!parser->bus)
@@ -1602,6 +1876,20 @@ static HRESULT CDECL wg_parser_connect(struct wg_parser *parser, uint64_t file_s
     parser->start_offset = parser->next_offset = parser->stop_offset = 0;
     parser->next_pull_offset = 0;
 
+    return S_OK;
+}
+
+static HRESULT CDECL wg_parser_connect(struct wg_parser *parser, uint64_t file_size)
+{
+    unsigned int i;
+    HRESULT hr;
+
+    parser->seekable = true;
+    parser->file_size = file_size;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
     if (!parser->init_gst(parser))
         return E_FAIL;
 
@@ -1627,6 +1915,43 @@ static HRESULT CDECL wg_parser_connect(struct wg_parser *parser, uint64_t file_s
     return S_OK;
 }
 
+static HRESULT CDECL wg_parser_connect_unseekable(struct wg_parser *parser,
+            const struct wg_format *in_format, uint32_t stream_count, const struct wg_format *out_formats, const struct wg_rect *apertures)
+{
+    unsigned int i;
+    HRESULT hr;
+
+    parser->seekable = false;
+    parser->flushing = false;
+    /* since typefind is not available here, we must have an input_format */
+    parser->input_format = *in_format;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
+    parser->stop_offset = -1;
+
+    parser->expected_stream_count = stream_count;
+    parser->streams = calloc(stream_count, sizeof(*parser->streams));
+
+    for (i = 0; i < stream_count; i++)
+    {
+        parser->streams[i] = calloc(1, sizeof(*parser->streams[i]));
+        parser->streams[i]->current_format = out_formats[i];
+        if (apertures)
+            parser->streams[i]->aperture = apertures[i];
+        parser->streams[i]->enabled = true;
+    }
+
+    if (!parser->init_gst(parser))
+        return E_FAIL;
+
+    if (parser->stream_count < parser->expected_stream_count)
+        return E_FAIL;
+
+    return S_OK;
+}
+
 static void free_stream(struct wg_parser_stream *stream)
 {
     if (stream->their_src)
@@ -1701,6 +2026,9 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
         return FALSE;
     }
 
+    if (parser->input_format.major_type)
+        g_object_set(G_OBJECT(element), "sink-caps", wg_format_to_caps(&parser->input_format), NULL);
+
     gst_bin_add(GST_BIN(parser->container), element);
     parser->decodebin = element;
 
@@ -1977,6 +2305,7 @@ static const struct unix_funcs funcs =
     wg_parser_destroy,
 
     wg_parser_connect,
+    wg_parser_connect_unseekable,
     wg_parser_disconnect,
 
     wg_parser_begin_flush,
@@ -2001,6 +2330,7 @@ static const struct unix_funcs funcs =
 
     wg_parser_stream_get_duration,
     wg_parser_stream_seek,
+    wg_parser_stream_drain,
 };
 
 NTSTATUS CDECL __wine_init_unix_lib(HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out)
-- 
2.30.2

From 450f8fbc17d7b9bac5428ef4db8da53a446b9ee8 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:53:02 -0400
Subject: [PATCH 10/40] winegstreamer: Implement ::Process(Input/Output) for
 decoder transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 532 +++++++++++++++++++++++++-
 1 file changed, 526 insertions(+), 6 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index dadd161bcc9..ddee03cf300 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -51,14 +51,47 @@ static struct decoder_desc
     },
 };
 
+struct pipeline_event
+{
+    enum
+    {
+        PIPELINE_EVENT_NONE,
+        PIPELINE_EVENT_PARSER_STARTED,
+        PIPELINE_EVENT_READ_REQUEST,
+    } type;
+    union
+    {
+        struct
+        {
+            struct wg_parser_stream *stream;
+        } parser_started;
+    } u;
+};
+
 struct mf_decoder
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
     enum decoder_type type;
     IMFMediaType *input_type, *output_type;
-    CRITICAL_SECTION cs;
-    BOOL video;
+    CRITICAL_SECTION cs, help_cs, event_cs;
+    CONDITION_VARIABLE help_cv, event_cv;
+    BOOL flushing, draining, eos, helper_thread_shutdown, video;
+    HANDLE helper_thread, read_thread;
+    uint64_t offset_tracker;
+    struct wg_parser *wg_parser;
+    struct wg_parser_stream *wg_stream;
+
+    struct
+    {
+        enum
+        {
+            HELP_REQ_NONE,
+            HELP_REQ_START_PARSER,
+        } type;
+    } help_request;
+
+    struct pipeline_event event;
 };
 
 static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
@@ -114,7 +147,15 @@ static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
             decoder->output_type = NULL;
         }
 
+        if (decoder->wg_stream)
+            unix_funcs->wg_parser_disconnect(decoder->wg_parser);
+
+        if (decoder->wg_parser)
+            unix_funcs->wg_parser_destroy(decoder->wg_parser);
+
         DeleteCriticalSection(&decoder->cs);
+        DeleteCriticalSection(&decoder->help_cs);
+        DeleteCriticalSection(&decoder->event_cs);
 
         heap_free(decoder);
     }
@@ -341,6 +382,12 @@ static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMF
 
         EnterCriticalSection(&decoder->cs);
 
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            unix_funcs->wg_parser_disconnect(decoder->wg_parser);
+        }
+
         if (decoder->input_type)
         {
             IMFMediaType_Release(decoder->input_type);
@@ -379,6 +426,12 @@ static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMF
 
     hr = S_OK;
 
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        unix_funcs->wg_parser_disconnect(decoder->wg_parser);
+    }
+
     if (!decoder->input_type)
         hr = MFCreateMediaType(&decoder->input_type);
 
@@ -388,6 +441,16 @@ static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMF
         decoder->input_type = NULL;
     }
 
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
     LeaveCriticalSection(&decoder->cs);
     return hr;
 }
@@ -412,6 +475,12 @@ static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IM
 
         EnterCriticalSection(&decoder->cs);
 
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            unix_funcs->wg_parser_disconnect(decoder->wg_parser);
+        }
+
         if (decoder->output_type)
         {
             IMFMediaType_Release(decoder->output_type);
@@ -450,6 +519,12 @@ static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IM
 
     hr = S_OK;
 
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        unix_funcs->wg_parser_disconnect(decoder->wg_parser);
+    }
+
     if (!decoder->output_type)
         hr = MFCreateMediaType(&decoder->output_type);
 
@@ -459,6 +534,16 @@ static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IM
         decoder->output_type = NULL;
     }
 
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
     LeaveCriticalSection(&decoder->cs);
     return hr;
 }
@@ -505,6 +590,124 @@ static HRESULT WINAPI mf_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMF
     return E_NOTIMPL;
 }
 
+static DWORD CALLBACK helper_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+
+    for(;;)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+
+        while(!decoder->helper_thread_shutdown && decoder->help_request.type == HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        if (decoder->helper_thread_shutdown)
+            return 0;
+
+        switch(decoder->help_request.type)
+        {
+            case HELP_REQ_START_PARSER:
+            {
+                struct wg_format input_format, output_format;
+                struct wg_rect wg_aperture = {0};
+                MFVideoArea *aperture = NULL;
+                UINT32 aperture_size;
+
+                decoder->help_request.type = HELP_REQ_NONE;
+                LeaveCriticalSection(&decoder->help_cs);
+
+                mf_media_type_to_wg_format(decoder->input_type, &input_format);
+                mf_media_type_to_wg_format(decoder->output_type, &output_format);
+
+                if (SUCCEEDED(IMFMediaType_GetAllocatedBlob(decoder->output_type,
+                    &MF_MT_MINIMUM_DISPLAY_APERTURE, (UINT8 **) &aperture, &aperture_size)))
+                {
+                    TRACE("Decoded media's aperture: x: %u %u/65536, y: %u %u/65536, area: %u x %u\n",
+                        aperture->OffsetX.value, aperture->OffsetX.fract,
+                        aperture->OffsetY.value, aperture->OffsetY.fract, aperture->Area.cx, aperture->Area.cy);
+
+                    /* TODO: verify aperture params? */
+
+                    wg_aperture.left = aperture->OffsetX.value;
+                    wg_aperture.top = aperture->OffsetY.value;
+                    wg_aperture.right = aperture->Area.cx;
+                    wg_aperture.bottom = aperture->Area.cy;
+
+                    CoTaskMemFree(aperture);
+                }
+
+                unix_funcs->wg_parser_connect_unseekable(decoder->wg_parser,
+                    &input_format, 1, &output_format, aperture ? &wg_aperture : NULL);
+
+                EnterCriticalSection(&decoder->event_cs);
+                while (decoder->event.type != PIPELINE_EVENT_NONE)
+                    SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+                decoder->event.type = PIPELINE_EVENT_PARSER_STARTED;
+                decoder->event.u.parser_started.stream = unix_funcs->wg_parser_get_stream(decoder->wg_parser, 0);
+
+                LeaveCriticalSection(&decoder->event_cs);
+                WakeAllConditionVariable(&decoder->event_cv);
+
+                break;
+            }
+            default:
+                assert(0);
+        }
+    }
+}
+
+/* We use a separate thread to wait for reads, as we may want to wait to WAIT_ANY
+   on a read and another event. */
+static DWORD CALLBACK read_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+    void *data;
+    uint64_t offset;
+    uint32_t size;
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_get_read_request(decoder->wg_parser, &data, &offset, &size))
+            continue;
+
+        if (decoder->helper_thread_shutdown)
+            break;
+
+        EnterCriticalSection(&decoder->event_cs);
+        while (decoder->event.type != PIPELINE_EVENT_NONE)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+        decoder->event.type = PIPELINE_EVENT_READ_REQUEST;
+        WakeAllConditionVariable(&decoder->event_cv);
+        while (decoder->event.type == PIPELINE_EVENT_READ_REQUEST)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+        LeaveCriticalSection(&decoder->event_cs);
+    }
+
+    return 0;
+}
+
+static struct pipeline_event get_pipeline_event(struct mf_decoder *decoder)
+{
+    struct pipeline_event ret;
+
+    EnterCriticalSection(&decoder->event_cs);
+    while(decoder->event.type == PIPELINE_EVENT_NONE)
+        SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+    ret = decoder->event;
+
+    if (ret.type != PIPELINE_EVENT_READ_REQUEST)
+    {
+        decoder->event.type = PIPELINE_EVENT_NONE;
+        WakeAllConditionVariable(&decoder->event_cv);
+    }
+
+    LeaveCriticalSection(&decoder->event_cs);
+
+    return ret;
+}
+
 static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
     FIXME("%p, %u %lu.\n", iface, message, param);
@@ -514,17 +717,318 @@ static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE
 
 static HRESULT WINAPI mf_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer = NULL;
+    HRESULT hr = S_OK;
+    BYTE *buffer_data;
+    DWORD buffer_size;
+    uint32_t size = 0;
+    uint64_t offset;
+    void *data;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->draining)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                break;
+            default:
+                assert(0);
+        }
+    }
+
+    if (decoder->wg_stream && !unix_funcs->wg_parser_stream_drain(decoder->wg_stream))
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    /* At this point, we either have a pre-init read request, or drained pipeline */
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    pip_event = get_pipeline_event(decoder);
+    assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+    for(;;)
+    {
+        uint32_t copy_size;
+
+        if (!unix_funcs->wg_parser_get_read_request(decoder->wg_parser, &data, &offset, &size))
+            continue;
+
+        copy_size = min(size, buffer_size);
+
+        if (offset != decoder->offset_tracker)
+        {
+            ERR("A seek is needed, MFTs don't support this!\n");
+            unix_funcs->wg_parser_complete_read_request(decoder->wg_parser, WG_READ_FAILURE, 0);
+            IMFMediaBuffer_Unlock(buffer);
+            hr = E_FAIL;
+            goto done;
+        }
+
+        memcpy(data, buffer_data, copy_size);
+
+        unix_funcs->wg_parser_complete_read_request(decoder->wg_parser, WG_READ_SUCCESS, buffer_size);
+
+        decoder->offset_tracker += copy_size;
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += copy_size;
+        buffer_size -= copy_size;
+
+        WARN("Input sample split into multiple read requests\n");
+    }
+
+    EnterCriticalSection(&decoder->event_cs);
+    decoder->event.type = PIPELINE_EVENT_NONE;
+    LeaveCriticalSection(&decoder->event_cs);
+    WakeAllConditionVariable(&decoder->event_cv);
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
 }
 
 static HRESULT WINAPI mf_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_DATA_BUFFER *relevant_buffer = NULL;
+    struct wg_parser_event event;
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer;
+    DWORD buffer_len;
+    unsigned int i;
+    BYTE *data;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    for (i = 0; i < count; i++)
+    {
+        MFT_OUTPUT_DATA_BUFFER *out_buffer = &samples[i];
+
+        if (out_buffer->dwStreamID != 0)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        if (relevant_buffer)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        relevant_buffer = out_buffer;
+    }
+
+    if (!relevant_buffer)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                LeaveCriticalSection(&decoder->cs);
+                return MF_E_TRANSFORM_NEED_MORE_INPUT;
+            default:
+                assert(0);
+        }
+    }
+
+    if (unix_funcs->wg_parser_stream_drain(decoder->wg_stream))
+    {
+        /* this would be unexpected, as we should get the EOS-event when a drain command completes. */
+        //assert (!decoder->draining);
+
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_stream_get_event(decoder->wg_stream, &event))
+        {
+            LeaveCriticalSection(&decoder->cs);
+            return E_FAIL;
+        }
+
+        if (event.type == WG_PARSER_EVENT_BUFFER)
+            break;
+
+        if (event.type == WG_PARSER_EVENT_EOS)
+        {
+            if (!decoder->draining)
+            {
+                LeaveCriticalSection(&decoder->cs);
+                WARN("Received EOS event while not draining\n");
+                return E_FAIL;
+            }
+            decoder->draining = FALSE;
+            LeaveCriticalSection(&decoder->cs);
+            return MF_E_TRANSFORM_NEED_MORE_INPUT;
+        }
+
+        assert(event.type != WG_PARSER_EVENT_NONE);
+    }
+
+    if (relevant_buffer->pSample)
+    {
+        if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(relevant_buffer->pSample, &buffer)))
+        {
+            ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+    }
+    else
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(event.u.buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+
+        if (FAILED(hr = MFCreateSample(&relevant_buffer->pSample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            IMFMediaBuffer_Release(buffer);
+            return hr;
+        }
+
+        if (FAILED(hr = IMFSample_AddBuffer(relevant_buffer->pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (buffer_len < event.u.buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, event.u.buffer.size);
+
+        if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, buffer_len)))
+        {
+            ERR("Failed to set size, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+    else if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, event.u.buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto out;
+    }
+
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (!unix_funcs->wg_parser_stream_copy_buffer(decoder->wg_stream, data, 0, min(buffer_len, event.u.buffer.size)))
+    {
+        hr = E_FAIL;
+        goto out;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Unlock(buffer)))
+    {
+        ERR("Failed to unlock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleTime(relevant_buffer->pSample, event.u.buffer.pts)))
+    {
+        ERR("Failed to set sample time, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleDuration(relevant_buffer->pSample, event.u.buffer.duration)))
+    {
+        ERR("Failed to set sample duration, hr %#x.\n", hr);
+        goto out;
+    }
+
+    relevant_buffer->dwStatus = 0;
+    relevant_buffer->pEvents = NULL;
+    *status = 0;
+
+    out:
+    if (SUCCEEDED(hr))
+        unix_funcs->wg_parser_stream_release_buffer(decoder->wg_stream);
+    LeaveCriticalSection(&decoder->cs);
+
+    if (FAILED(hr))
+    {
+        IMFSample_Release(relevant_buffer->pSample);
+        relevant_buffer->pSample = NULL;
+    }
+
+    IMFMediaBuffer_Release(buffer);
+
+    return hr;
 }
 
 static const IMFTransformVtbl mf_decoder_vtbl =
@@ -560,6 +1064,7 @@ static const IMFTransformVtbl mf_decoder_vtbl =
 HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
 {
     struct mf_decoder *object;
+    struct wg_parser *parser;
 
     TRACE("%s, %p %u.\n", debugstr_guid(riid), obj, type);
 
@@ -573,6 +1078,21 @@ HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
     object->video = decoder_descs[type].major_type == &MFMediaType_Video;
 
     InitializeCriticalSection(&object->cs);
+    InitializeCriticalSection(&object->help_cs);
+    InitializeCriticalSection(&object->event_cs);
+    InitializeConditionVariable(&object->help_cv);
+    InitializeConditionVariable(&object->event_cv);
+
+    object->helper_thread = CreateThread(NULL, 0, helper_thread_func, object, 0, NULL);
+    object->read_thread = CreateThread(NULL, 0, read_thread_func, object, 0, NULL);
+
+    if (!(parser = unix_funcs->wg_decodebin_parser_create()))
+    {
+        ERR("Failed to create Decoder MFT type %u: Unspecified GStreamer error\n", type);
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+    object->wg_parser = parser;
 
     *obj = &object->IMFTransform_iface;
     return S_OK;
-- 
2.30.2

From e0ef75676850eed550fca3b3aa4b28263a279c5a Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:54:03 -0400
Subject: [PATCH 11/40] winestreamer: Implement ::ProcessMessage for decoder
 transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 96 ++++++++++++++++++++++++++-
 1 file changed, 94 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index ddee03cf300..48293249e7d 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -710,9 +710,101 @@ static struct pipeline_event get_pipeline_event(struct mf_decoder *decoder)
 
 static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %u %lu.\n", iface, message, param);
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %x %lu.\n", decoder, message, param);
+
+    EnterCriticalSection(&decoder->cs);
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    hr = S_OK;
+
+    switch (message)
+    {
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        case MFT_MESSAGE_NOTIFY_START_OF_STREAM:
+            break;
+        case MFT_MESSAGE_NOTIFY_END_OF_STREAM:
+        {
+            if (param)
+            {
+                hr = MF_E_INVALIDSTREAMNUMBER;
+                break;
+            }
+            if (!decoder->wg_stream)
+            {
+                ERR("End-Of-Stream marked on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            decoder->eos = TRUE;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_DRAIN:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Drain requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            unix_funcs->wg_parser_complete_read_request(decoder->wg_parser, WG_READ_EOS, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->draining = TRUE;
+            decoder->offset_tracker = 0;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Flush requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            unix_funcs->wg_parser_complete_read_request(decoder->wg_parser, WG_READ_FLUSHING, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->offset_tracker = 0;
+            break;
+        }
+        default:
+        {
+            ERR("Unhandled message type %x.\n", message);
+            hr = E_FAIL;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
 }
 
 static HRESULT WINAPI mf_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
-- 
2.30.2

From 73df9b71d7802bdd96598f5cda43f789bfff8d2c Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:55:15 -0400
Subject: [PATCH 12/40] winegstreamer: Semi-stub ::GetAttributes for decoder
 transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index 48293249e7d..5b039e62de0 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -257,9 +257,9 @@ static HRESULT WINAPI mf_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD
 
 static HRESULT WINAPI mf_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
-    FIXME("%p, %p.\n", iface, attributes);
+    FIXME("%p, %p. semi-stub!\n", iface, attributes);
 
-    return E_NOTIMPL;
+    return MFCreateAttributes(attributes, 0);
 }
 
 static HRESULT WINAPI mf_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
-- 
2.30.2

From 40eabc6961483a0e26f47344118efd34897575a4 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:57:11 -0400
Subject: [PATCH 13/40] winegstreamer: Register the H.264 decoder transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/mfplat.c | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 48733d8e205..61e93aa4874 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -453,6 +453,20 @@ static const GUID *audio_converter_supported_types[] =
     &MFAudioFormat_Float,
 };
 
+static WCHAR h264_decoderW[] = L"H.264 Decoder";
+static const GUID *h264_decoder_input_types[] =
+{
+    &MFVideoFormat_H264,
+};
+static const GUID *h264_decoder_output_types[] =
+{
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YV12,
+};
+
 static const struct mft
 {
     const GUID *clsid;
@@ -478,6 +492,17 @@ mfts[] =
         ARRAY_SIZE(audio_converter_supported_types),
         audio_converter_supported_types,
     },
+    {
+        &CLSID_CMSH264DecoderMFT,
+        &MFT_CATEGORY_VIDEO_DECODER,
+        h264_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(h264_decoder_input_types),
+        h264_decoder_input_types,
+        ARRAY_SIZE(h264_decoder_output_types),
+        h264_decoder_output_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
-- 
2.30.2

From 4ed1f355e5abc75fe04d6e97038280124d36be01 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:59:29 -0400
Subject: [PATCH 14/40] winegstreamer: Introduce AAC decoder transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/decode_transform.c        | 10 +++
 dlls/winegstreamer/gst_private.h             | 17 ++++++
 dlls/winegstreamer/mfplat.c                  | 64 +++++++++++++++++++-
 dlls/winegstreamer/quartz_parser.c           |  1 +
 dlls/winegstreamer/wg_parser.c               | 62 +++++++++++++++++++
 dlls/winegstreamer/winegstreamer_classes.idl |  6 ++
 include/mfidl.idl                            |  1 +
 7 files changed, 160 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
index 5b039e62de0..642d8aff264 100644
--- a/dlls/winegstreamer/decode_transform.c
+++ b/dlls/winegstreamer/decode_transform.c
@@ -33,6 +33,9 @@ const GUID *h264_input_types[] = {&MFVideoFormat_H264};
 /* NV12 comes first https://docs.microsoft.com/en-us/windows/win32/medfound/mft-decoder-expose-output-types-in-native-order . thanks to @vitorhnn */
 const GUID *h264_output_types[] = {&MFVideoFormat_NV12, &MFVideoFormat_I420, &MFVideoFormat_IYUV, &MFVideoFormat_YUY2, &MFVideoFormat_YV12};
 
+const GUID *aac_input_types[] = {&MFAudioFormat_AAC};
+const GUID *aac_output_types[] = {&MFAudioFormat_Float};
+
 static struct decoder_desc
 {
     const GUID *major_type;
@@ -49,6 +52,13 @@ static struct decoder_desc
         h264_output_types,
         ARRAY_SIZE(h264_output_types),
     },
+    { /* DECODER_TYPE_AAC */
+        &MFMediaType_Audio,
+        aac_input_types,
+        ARRAY_SIZE(aac_input_types),
+        aac_output_types,
+        ARRAY_SIZE(aac_output_types),
+    }
 };
 
 struct pipeline_event
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 25694aae84d..6407aff484c 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -127,11 +127,27 @@ struct wg_format
                 WG_AUDIO_FORMAT_MPEG1_LAYER1,
                 WG_AUDIO_FORMAT_MPEG1_LAYER2,
                 WG_AUDIO_FORMAT_MPEG1_LAYER3,
+
+                WG_AUDIO_FORMAT_AAC,
             } format;
 
             uint32_t channels;
             uint32_t channel_mask; /* In WinMM format. */
             uint32_t rate;
+
+            union
+            {
+                struct
+                {
+                    uint32_t payload_type;
+                    uint32_t indication;
+                    /* The definition of this structure is found in ISO/IEC 14496-3,
+                       which we don't have access to, so we'll just keep
+                       the size set to the largest instance we've seen used. */
+                    unsigned char audio_specifc_config[2];
+                    uint32_t asp_size;
+                } aac;
+            } compressed;
         } audio;
     } u;
 };
@@ -256,6 +272,7 @@ HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 enum decoder_type
 {
     DECODER_TYPE_H264,
+    DECODER_TYPE_AAC,
 };
 HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type) DECLSPEC_HIDDEN;
 
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 61e93aa4874..7442e1133db 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -407,6 +407,11 @@ static HRESULT h264_decoder_create(REFIID riid, void **ret)
     return decode_transform_create(riid, ret, DECODER_TYPE_H264);
 }
 
+static HRESULT aac_decoder_create(REFIID riid, void **ret)
+{
+    return decode_transform_create(riid, ret, DECODER_TYPE_AAC);
+}
+
 static const struct class_object
 {
     const GUID *clsid;
@@ -418,6 +423,7 @@ class_objects[] =
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
     { &CLSID_CMSH264DecoderMFT, &h264_decoder_create },
+    { &CLSID_CMSAACDecMFT, &aac_decoder_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
@@ -598,7 +604,8 @@ static IMFMediaType *mf_media_type_from_wg_format_audio(const struct wg_format *
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, audio_formats[i].depth);
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, format->u.audio.rate);
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, format->u.audio.channels);
-            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, format->u.audio.channel_mask);
+            if (format->u.audio.channel_mask)
+                IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, format->u.audio.channel_mask);
 
             return type;
         }
@@ -626,6 +633,7 @@ static IMFMediaType *mf_media_type_from_wg_format_video(const struct wg_format *
             IMFMediaType_SetUINT64(type, &MF_MT_FRAME_RATE,
                     make_uint64(format->u.video.fps_n, format->u.video.fps_d));
             IMFMediaType_SetUINT32(type, &MF_MT_COMPRESSED, FALSE);
+            IMFMediaType_SetUINT32(type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
 
             return type;
         }
@@ -684,6 +692,8 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, struct wg_forma
             channel_mask = KSAUDIO_SPEAKER_MONO;
         else if (channels == 2)
             channel_mask = KSAUDIO_SPEAKER_STEREO;
+        else if IsEqualGUID(&subtype, &MFAudioFormat_AAC)
+            channel_mask = 0;
         else
         {
             FIXME("Channel mask is not set.\n");
@@ -696,6 +706,58 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, struct wg_forma
     format->u.audio.channel_mask = channel_mask;
     format->u.audio.rate = rate;
 
+    if (IsEqualGUID(&subtype, &MFAudioFormat_AAC))
+    {
+        UINT32 payload_type, indication, user_data_size;
+        unsigned char *user_data;
+
+        format->u.audio.format = WG_AUDIO_FORMAT_AAC;
+
+        if (SUCCEEDED(IMFMediaType_GetBlobSize(type, &MF_MT_USER_DATA, &user_data_size)))
+        {
+            user_data = malloc(user_data_size);
+            if (SUCCEEDED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, user_data, user_data_size, NULL)))
+            {
+                struct {
+                    WORD payload_type;
+                    WORD indication;
+                    WORD type;
+                    WORD reserved1;
+                    DWORD reserved2;
+                } *aac_info = (void *) user_data;
+
+                format->u.audio.compressed.aac.payload_type = aac_info->payload_type;
+                format->u.audio.compressed.aac.indication = aac_info->indication;
+
+                /* Audio specific config is stored at after HEAACWAVEINFO in MF_MT_USER_DATA
+                    https://docs.microsoft.com/en-us/windows/win32/api/mmreg/ns-mmreg-heaacwaveformat */
+                if (user_data_size > 12)
+                {
+                    user_data += 12;
+                    user_data_size -= 12;
+
+                    if (user_data_size > sizeof(format->u.audio.compressed.aac.audio_specifc_config))
+                    {
+                        FIXME("Encountered Audio-Specific-Config with a size larger than we support %u\n", user_data_size);
+                        user_data_size = sizeof(format->u.audio.compressed.aac.audio_specifc_config);
+                    }
+
+                    memcpy(format->u.audio.compressed.aac.audio_specifc_config, user_data, user_data_size);
+                    format->u.audio.compressed.aac.asp_size = user_data_size;
+                }
+
+            }
+        }
+
+        if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_PAYLOAD_TYPE, &payload_type)))
+            format->u.audio.compressed.aac.payload_type = payload_type;
+
+        if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, &indication)))
+            format->u.audio.compressed.aac.indication = indication;
+
+        return;
+    }
+
     for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
     {
         if (IsEqualGUID(&subtype, audio_formats[i].subtype) && depth == audio_formats[i].depth)
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index ac6e76856ca..331e706af74 100644
--- a/dlls/winegstreamer/quartz_parser.c
+++ b/dlls/winegstreamer/quartz_parser.c
@@ -102,6 +102,7 @@ static bool amt_from_wg_format_audio(AM_MEDIA_TYPE *mt, const struct wg_format *
     switch (format->u.audio.format)
     {
     case WG_AUDIO_FORMAT_UNKNOWN:
+    case WG_AUDIO_FORMAT_AAC:
         return false;
 
     case WG_AUDIO_FORMAT_MPEG1_LAYER1:
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 3a691589e53..54fc5b69da7 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -395,6 +395,13 @@ static void wg_set_caps_from_wg_format(GstCaps *caps, const struct wg_format *fo
             gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.video.fps_n, format->u.video.fps_d, NULL);
             break;
         }
+        case WG_MAJOR_TYPE_AUDIO:
+        {
+            gst_caps_set_simple(caps, "rate", G_TYPE_INT, format->u.audio.rate, NULL);
+            gst_caps_set_simple(caps, "channels", G_TYPE_INT, format->u.audio.channels, NULL);
+            if (format->u.audio.channel_mask)
+                gst_caps_set_simple(caps, "channel-mask", G_TYPE_INT, format->u.audio.channel_mask, NULL);
+        }
         default:
             break;
     }
@@ -406,6 +413,61 @@ static GstCaps *wg_format_to_caps_audio(const struct wg_format *format)
     GstAudioFormat audio_format;
     GstAudioInfo info;
 
+    /* compressed types */
+
+    if (format->u.audio.format == WG_AUDIO_FORMAT_AAC)
+    {
+        const char *profile, *level;
+        GstBuffer *audio_specific_config;
+        GstCaps *caps = gst_caps_new_empty_simple("audio/mpeg");
+        wg_set_caps_from_wg_format(caps, format);
+
+        gst_caps_set_simple(caps, "mpegversion", G_TYPE_INT, 4, NULL);
+
+        switch (format->u.audio.compressed.aac.payload_type)
+        {
+            case 0:
+                gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "raw", NULL);
+                break;
+            case 1:
+                gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "adts", NULL);
+                break;
+            case 2:
+                gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "adif", NULL);
+                break;
+            case 3:
+                gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "loas", NULL);
+                break;
+            default:
+                gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "raw", NULL);
+        };
+
+        switch (format->u.audio.compressed.aac.indication)
+        {
+            case 0x29: profile = "lc"; level = "2";  break;
+            case 0x2A: profile = "lc"; level = "4"; break;
+            case 0x2B: profile = "lc"; level = "5"; break;
+            default:
+                FIXME("Unrecognized profile-level-indication %u\n", format->u.audio.compressed.aac.indication);
+                /* fallthrough */
+            case 0x00: case 0xFE: profile = level = NULL; break; /* unspecified */
+        }
+
+        if (profile)
+            gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+        if (level)
+            gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+        audio_specific_config = gst_buffer_new_allocate(NULL, format->u.audio.compressed.aac.asp_size, NULL);
+        gst_buffer_fill(audio_specific_config, 0, format->u.audio.compressed.aac.audio_specifc_config, format->u.audio.compressed.aac.asp_size);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, audio_specific_config, NULL);
+        gst_buffer_unref(audio_specific_config);
+
+        return caps;
+    }
+
+    /* uncompressed_types */
+
     if ((audio_format = wg_audio_format_to_gst(format->u.audio.format)) == GST_AUDIO_FORMAT_UNKNOWN)
         return NULL;
 
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 064a6872c79..4c58d83403b 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -73,3 +73,9 @@ coclass WINEAudioConverter { }
     uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
 ]
 coclass CMSH264DecoderMFT { }
+
+[
+    threading(both),
+    uuid(32d186a7-218f-4c75-8876-dd77273a8999)
+]
+coclass CMSAACDecMFT { }
diff --git a/include/mfidl.idl b/include/mfidl.idl
index 63b2ab84c92..d6f18eb8661 100644
--- a/include/mfidl.idl
+++ b/include/mfidl.idl
@@ -1413,3 +1413,4 @@ cpp_quote("EXTERN_GUID(MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS, 0xba491366, 0xb
 
 cpp_quote("EXTERN_GUID(CLSID_VideoProcessorMFT, 0x88753b26, 0x5b24, 0x49bd, 0xb2, 0xe7, 0xc, 0x44, 0x5c, 0x78, 0xc9, 0x82);")
 cpp_quote("EXTERN_GUID(CLSID_CMSH264DecoderMFT, 0x62ce7e72, 0x4c71, 0x4d20, 0xb1, 0x5d, 0x45, 0x28, 0x31, 0xa8, 0x7d, 0x9d);")
+cpp_quote("EXTERN_GUID(CLSID_CMSAACDecMFT, 0x32d186a7, 0x218f, 0x4c75, 0x88, 0x76, 0xdd, 0x77, 0x27, 0x3a, 0x89, 0x99);")
-- 
2.30.2

From 607508fdc494a72ce8f49d8c0852d3be4528a829 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 17:00:27 -0400
Subject: [PATCH 15/40] winegstreamer: Register the AAC decoder transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/mfplat.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 7442e1133db..6449b38f5f1 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -473,6 +473,17 @@ static const GUID *h264_decoder_output_types[] =
     &MFVideoFormat_YV12,
 };
 
+static WCHAR aac_decoderW[] = L"AAC Decoder";
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_Float,
+    &MFAudioFormat_PCM,
+};
+
 static const struct mft
 {
     const GUID *clsid;
@@ -509,6 +520,17 @@ mfts[] =
         ARRAY_SIZE(h264_decoder_output_types),
         h264_decoder_output_types,
     },
+    {
+        &CLSID_CMSAACDecMFT,
+        &MFT_CATEGORY_AUDIO_DECODER,
+        aac_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(aac_decoder_input_types),
+        aac_decoder_input_types,
+        ARRAY_SIZE(aac_decoder_output_types),
+        aac_decoder_output_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
-- 
2.30.2

From 4801e1c1abf8d0a9d1d1712d0432b985a903ab9d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 17:00:51 -0400
Subject: [PATCH 16/40] winegstreamer: Rename GStreamer objects to be more
 generic.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/wg_parser.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 54fc5b69da7..87ce7e11871 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1208,7 +1208,7 @@ static struct wg_parser_stream *create_stream(struct wg_parser *parser)
     pthread_cond_init(&stream->event_cond, NULL);
     pthread_cond_init(&stream->event_empty_cond, NULL);
 
-    sprintf(pad_name, "qz_sink_%u", parser->stream_count);
+    sprintf(pad_name, "wine_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
     gst_pad_set_element_private(stream->my_sink, stream);
     gst_pad_set_chain_function(stream->my_sink, sink_chain_cb);
@@ -1914,7 +1914,7 @@ static LONGLONG query_duration(GstPad *pad)
 
 static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
 {
-    GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("quartz_src",
+    GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("wine_src",
             GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
 
     parser->sink_connected = true;
@@ -1928,7 +1928,7 @@ static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
     parser->container = gst_bin_new(NULL);
     gst_element_set_bus(parser->container, parser->bus);
 
-    parser->my_src = gst_pad_new_from_static_template(&src_template, "quartz-src");
+    parser->my_src = gst_pad_new_from_static_template(&src_template, "wine-src");
     gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
     gst_pad_set_query_function(parser->my_src, src_query_cb);
     gst_pad_set_activatemode_function(parser->my_src, src_activate_mode_cb);
-- 
2.30.2

From 762775b751a0c4c94fce757846298d5e95fa2ea3 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 17:01:54 -0400
Subject: [PATCH 17/40] winegstreamer: Report streams backwards in media
 source.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/media_source.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 331c87dc371..14fcac235b0 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1153,7 +1153,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     descriptors = malloc(object->stream_count * sizeof(IMFStreamDescriptor *));
     for (i = 0; i < object->stream_count; i++)
     {
-        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, &descriptors[i]);
+        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, &descriptors[object->stream_count - 1 - i]);
     }
 
     if (FAILED(hr = MFCreatePresentationDescriptor(object->stream_count, descriptors, &object->pres_desc)))
-- 
2.30.2

From a1581a7606a40b97ec9f38005df1f9ee1def743d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 14:07:52 -0400
Subject: [PATCH 18/40] winegstreamer: Implement ::Process(Input/Output) for
 audio conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/audioconvert.c | 280 +++++++++++++++++++++++++++++-
 dlls/winegstreamer/gst_private.h  |   1 +
 dlls/winegstreamer/wg_parser.c    |  93 ++++++++++
 3 files changed, 367 insertions(+), 7 deletions(-)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 33350fb3566..8405f3bedc5 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -35,6 +35,10 @@ struct audio_converter
     IMFMediaType *input_type;
     IMFMediaType *output_type;
     CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
 };
 
 static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
@@ -80,6 +84,10 @@ static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->stream)
+            unix_funcs->wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            unix_funcs->wg_parser_destroy(transform->parser);
         free(transform);
     }
 
@@ -272,6 +280,7 @@ fail:
 static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     GUID major_type, subtype;
+    struct wg_format format;
     DWORD unused;
     HRESULT hr;
 
@@ -291,6 +300,11 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
 
         if (converter->input_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->input_type);
             converter->input_type = NULL;
         }
@@ -317,6 +331,10 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
     if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
         return MF_E_INVALIDTYPE;
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -336,6 +354,21 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
         converter->input_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -345,6 +378,7 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 {
     struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
     GUID major_type, subtype;
+    struct wg_format format;
     DWORD unused;
     HRESULT hr;
 
@@ -353,9 +387,6 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
 
-    if (!converter->input_type)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
-
     if (!type)
     {
         if (flags & MFT_SET_TYPE_TEST_ONLY)
@@ -365,6 +396,11 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 
         if (converter->output_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->output_type);
             converter->output_type = NULL;
         }
@@ -391,6 +427,10 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
     if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
         return MF_E_INVALIDTYPE;
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -410,6 +450,21 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
         converter->output_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -521,17 +576,221 @@ static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
 static HRESULT WINAPI audio_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    void *data;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+            continue;
+
+        memcpy(data, buffer_data, min(buffer_size, size));
+
+        unix_funcs->wg_parser_complete_read_request(converter->parser, WG_READ_SUCCESS, buffer_size);
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI audio_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    IMFMediaBuffer *buffer = NULL;
+    struct wg_parser_event event;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    for (;;)
+    {
+        unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+        switch (event.type)
+        {
+            case WG_PARSER_EVENT_BUFFER:
+                break;
+
+            case WG_PARSER_EVENT_SEGMENT:
+                continue;
+
+            default:
+                WARN("Unexpected event, %u\n", event.type);
+                continue;
+        }
+        break;
+    }
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(event.u.buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < event.u.buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, event.u.buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, event.u.buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!unix_funcs->wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, event.u.buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (allocated_sample && FAILED(hr))
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static const IMFTransformVtbl audio_converter_vtbl =
@@ -579,6 +838,13 @@ HRESULT audio_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": audio_converter_lock");
 
+    if (!(object->parser = unix_funcs->wg_raw_media_converter_create()))
+    {
+        ERR("Failed to create audio converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
     *ret = &object->IMFTransform_iface;
     return S_OK;
 }
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 6407aff484c..ee6d19e74b6 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -203,6 +203,7 @@ struct unix_funcs
     struct wg_parser *(CDECL *wg_avi_parser_create)(void);
     struct wg_parser *(CDECL *wg_mpeg_audio_parser_create)(void);
     struct wg_parser *(CDECL *wg_wave_parser_create)(void);
+    struct wg_parser *(CDECL *wg_raw_media_converter_create)(void);
     void (CDECL *wg_parser_destroy)(struct wg_parser *parser);
 
     HRESULT (CDECL *wg_parser_connect)(struct wg_parser *parser, uint64_t file_size);
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 87ce7e11871..394a0d65aeb 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -2289,6 +2289,89 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
     return TRUE;
 }
 
+static BOOL raw_media_converter_init_gst(struct wg_parser *parser)
+{
+    BOOL video = parser->input_format.major_type == WG_MAJOR_TYPE_VIDEO;
+    struct wg_parser_stream *stream;
+    GstElement *convert, *resampler;
+    GstPad *their_src;
+    int ret;
+
+    if (parser->seekable)
+        return FALSE;
+
+    if (parser->expected_stream_count != 1)
+        return FALSE;
+
+    if (video)
+    {
+        if (!(convert = gst_element_factory_make("videoconvert", NULL)))
+        {
+            ERR("Failed to create videoconvert; are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void*));
+            return FALSE;
+        }
+
+        gst_bin_add(GST_BIN(parser->container), convert);
+
+        parser->their_sink = gst_element_get_static_pad(convert, "sink");
+        their_src = gst_element_get_static_pad(convert, "src");
+    }
+    else
+    {
+        if (!(convert = gst_element_factory_make("audioconvert", NULL)))
+        {
+            ERR("Failed to create audioconvert; are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void*));
+            return FALSE;
+        }
+
+        gst_bin_add(GST_BIN(parser->container), convert);
+
+        if (!(resampler = gst_element_factory_make("audioresample", NULL)))
+        {
+            ERR("Failed to create audioresample; are %u-bit GStreamer \"base\" plugins installed?\n",
+                    8 * (int)sizeof(void*));
+            return FALSE;
+        }
+
+        gst_bin_add(GST_BIN(parser->container), resampler);
+
+        gst_element_link(convert, resampler);
+        parser->their_sink = gst_element_get_static_pad(convert, "sink");
+        their_src = gst_element_get_static_pad(resampler, "src");
+    }
+
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        ERR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = their_src;
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        ERR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    gst_pad_set_active(stream->my_sink, 1);
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        ERR("Failed to play stream.\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static struct wg_parser *wg_parser_create(void)
 {
     struct wg_parser *parser;
@@ -2342,6 +2425,15 @@ static struct wg_parser * CDECL wg_wave_parser_create(void)
     return parser;
 }
 
+static struct wg_parser * CDECL wg_raw_media_converter_create(void)
+{
+    struct wg_parser *parser;
+
+    if ((parser = wg_parser_create()))
+        parser->init_gst = raw_media_converter_init_gst;
+    return parser;
+}
+
 static void CDECL wg_parser_destroy(struct wg_parser *parser)
 {
     if (parser->bus)
@@ -2364,6 +2456,7 @@ static const struct unix_funcs funcs =
     wg_avi_parser_create,
     wg_mpeg_audio_parser_create,
     wg_wave_parser_create,
+    wg_raw_media_converter_create,
     wg_parser_destroy,
 
     wg_parser_connect,
-- 
2.30.2

From 61a914b8a2d6c1104c216acb0ced7c46530b7c60 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 15:12:20 -0400
Subject: [PATCH 19/40] winegstreamer: Implement ::Get(Input/Output)StreamInfo
 for audio conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/audioconvert.c | 42 ++++++++++++++++++++++++++++---
 1 file changed, 38 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 8405f3bedc5..4ad64d58e47 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -123,16 +123,50 @@ static HRESULT WINAPI audio_converter_GetStreamIDs(IMFTransform *iface, DWORD in
 
 static HRESULT WINAPI audio_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_GetUINT32(converter->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        IMFMediaType_GetUINT32(converter->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
-- 
2.30.2

From 26a0ebd578930bca265ddac7d0516901335e2e55 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 15:19:32 -0400
Subject: [PATCH 20/40] winegstreamer: Semi-stub Get*Attributes functions for
 audio converter transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/audioconvert.c | 39 +++++++++++++++++++++++++++----
 1 file changed, 35 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 4ad64d58e47..43fe8b04e64 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -39,6 +39,7 @@ struct audio_converter
     LONGLONG buffer_pts, buffer_dur;
     struct wg_parser *parser;
     struct wg_parser_stream *stream;
+    IMFAttributes *attributes, *output_attributes;
 };
 
 static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
@@ -84,6 +85,10 @@ static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->attributes)
+            IMFAttributes_Release(transform->attributes);
+        if (transform->output_attributes)
+            IMFAttributes_Release(transform->output_attributes);
         if (transform->stream)
             unix_funcs->wg_parser_disconnect(transform->parser);
         if (transform->parser)
@@ -171,9 +176,14 @@ static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, D
 
 static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
-    FIXME("%p, %p.\n", iface, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, attributes);
+
+    *attributes = converter->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
@@ -187,9 +197,17 @@ static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *ifa
 static HRESULT WINAPI audio_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %u, %p.\n", iface, id, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    *attributes = converter->output_attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
@@ -860,6 +878,7 @@ static const IMFTransformVtbl audio_converter_vtbl =
 HRESULT audio_converter_create(REFIID riid, void **ret)
 {
     struct audio_converter *object;
+    HRESULT hr;
 
     TRACE("%s %p\n", debugstr_guid(riid), ret);
 
@@ -872,6 +891,18 @@ HRESULT audio_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": audio_converter_lock");
 
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
     if (!(object->parser = unix_funcs->wg_raw_media_converter_create()))
     {
         ERR("Failed to create audio converter due to GStreamer error.\n");
-- 
2.30.2

From 001b02e5d818d4b7bec14aba180613a63225388e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 15:35:20 -0400
Subject: [PATCH 21/40] winegstreamer: Introduce color conversion transform.

Serves as a wrapper of videoconvert, and exposes the CColorConverterDMO MFT interface.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/colorconvert.c            | 298 +++++++++++++++++++
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/mfplat.c                  |   2 +
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 include/wmcodecdsp.idl                       |   5 +
 6 files changed, 313 insertions(+)
 create mode 100644 dlls/winegstreamer/colorconvert.c

diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 7459cccf7e4..ec688f4425b 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -8,6 +8,7 @@ EXTRADLLFLAGS = -mno-cygwin
 
 C_SRCS = \
 	audioconvert.c \
+	colorconvert.c \
 	decode_transform.c \
 	main.c \
 	media_source.c \
diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
new file mode 100644
index 00000000000..1f0d061a30c
--- /dev/null
+++ b/dlls/winegstreamer/colorconvert.c
@@ -0,0 +1,298 @@
+/* GStreamer Color Converter
+ *
+ * Copyright 2020 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct color_converter
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+};
+
+static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct color_converter, IMFTransform_iface);
+}
+
+static HRESULT WINAPI color_converter_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IMFTransform) ||
+        IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI color_converter_AddRef(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI color_converter_Release(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI color_converter_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    FIXME("%p %u %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    FIXME("%p %u %p.\n", iface, id, info);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p.\n", iface, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    TRACE("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("%p, %u %lu.\n", iface, message, param);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl color_converter_vtbl =
+{
+    color_converter_QueryInterface,
+    color_converter_AddRef,
+    color_converter_Release,
+    color_converter_GetStreamLimits,
+    color_converter_GetStreamCount,
+    color_converter_GetStreamIDs,
+    color_converter_GetInputStreamInfo,
+    color_converter_GetOutputStreamInfo,
+    color_converter_GetAttributes,
+    color_converter_GetInputStreamAttributes,
+    color_converter_GetOutputStreamAttributes,
+    color_converter_DeleteInputStream,
+    color_converter_AddInputStreams,
+    color_converter_GetInputAvailableType,
+    color_converter_GetOutputAvailableType,
+    color_converter_SetInputType,
+    color_converter_SetOutputType,
+    color_converter_GetInputCurrentType,
+    color_converter_GetOutputCurrentType,
+    color_converter_GetInputStatus,
+    color_converter_GetOutputStatus,
+    color_converter_SetOutputBounds,
+    color_converter_ProcessEvent,
+    color_converter_ProcessMessage,
+    color_converter_ProcessInput,
+    color_converter_ProcessOutput,
+};
+
+HRESULT color_converter_create(REFIID riid, void **ret)
+{
+    struct color_converter *object;
+
+    TRACE("%s %p\n", debugstr_guid(riid), ret);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &color_converter_vtbl;
+    object->refcount = 1;
+
+    *ret = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index ee6d19e74b6..0827f70112f 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -269,6 +269,7 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format) DE
 HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
 
 HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT color_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 
 enum decoder_type
 {
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 6449b38f5f1..d31d87b2d1d 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -22,6 +22,7 @@
 #include "mfapi.h"
 #include "ks.h"
 #include "ksmedia.h"
+#include "wmcodecdsp.h"
 
 #include "wine/debug.h"
 
@@ -422,6 +423,7 @@ class_objects[] =
     { &CLSID_VideoProcessorMFT, &video_processor_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
+    { &CLSID_CColorConvertDMO, &color_converter_create },
     { &CLSID_CMSH264DecoderMFT, &h264_decoder_create },
     { &CLSID_CMSAACDecMFT, &aac_decoder_create },
 };
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 4c58d83403b..093fca3521e 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -79,3 +79,9 @@ coclass CMSH264DecoderMFT { }
     uuid(32d186a7-218f-4c75-8876-dd77273a8999)
 ]
 coclass CMSAACDecMFT { }
+
+[
+    threading(both),
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO { }
diff --git a/include/wmcodecdsp.idl b/include/wmcodecdsp.idl
index 61381bee6d4..87305422332 100644
--- a/include/wmcodecdsp.idl
+++ b/include/wmcodecdsp.idl
@@ -30,3 +30,8 @@ coclass CMP3DecMediaObject {}
     uuid(f447b69e-1884-4a7e-8055-346f74d6edb3)
 ]
 coclass CResamplerMediaObject {}
+
+[
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO {}
-- 
2.30.2

From 38a76e0e7e0700e94fb382500ab0ef3e9d50af03 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 15:37:17 -0400
Subject: [PATCH 22/40] winegstreamer: Register the color conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/mfplat.c | 33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index d31d87b2d1d..4db431d839d 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -461,6 +461,26 @@ static const GUID *audio_converter_supported_types[] =
     &MFAudioFormat_Float,
 };
 
+static WCHAR color_converterW[] = L"Color Converter";
+static const GUID *color_converter_supported_types[] =
+{
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
 static WCHAR h264_decoderW[] = L"H.264 Decoder";
 static const GUID *h264_decoder_input_types[] =
 {
@@ -511,6 +531,17 @@ mfts[] =
         ARRAY_SIZE(audio_converter_supported_types),
         audio_converter_supported_types,
     },
+    {
+        &CLSID_CColorConvertDMO,
+        &MFT_CATEGORY_VIDEO_EFFECT,
+        color_converterW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+    },
     {
         &CLSID_CMSH264DecoderMFT,
         &MFT_CATEGORY_VIDEO_DECODER,
@@ -539,7 +570,7 @@ HRESULT mfplat_DllRegisterServer(void)
 {
     unsigned int i, j;
     HRESULT hr;
-    MFT_REGISTER_TYPE_INFO input_types[2], output_types[2];
+    MFT_REGISTER_TYPE_INFO input_types[15], output_types[15];
 
     for (i = 0; i < ARRAY_SIZE(mfts); i++)
     {
-- 
2.30.2

From 77fa91c34ccb9701b674427832aba024264af258 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 15:41:33 -0400
Subject: [PATCH 23/40] winegstreamer: Implement ::GetInputAvailableType for
 color conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 48 +++++++++++++++++++++++++++++--
 1 file changed, 46 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 1f0d061a30c..078782daaed 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -26,6 +26,24 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+static const GUID *raw_types[] = {
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
 struct color_converter
 {
     IMFTransform IMFTransform_iface;
@@ -160,9 +178,35 @@ static HRESULT WINAPI color_converter_AddInputStreams(IMFTransform *iface, DWORD
 static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    IMFMediaType *ret;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
-- 
2.30.2

From 042f02feb85a9b41263961b14019cb4ed987857c Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 16:01:18 -0400
Subject: [PATCH 24/40] winegstreamer: Implement ::SetInputType for color
 conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 75 ++++++++++++++++++++++++++++++-
 1 file changed, 73 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 078782daaed..06186ed7846 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -48,6 +48,8 @@ struct color_converter
 {
     IMFTransform IMFTransform_iface;
     LONG refcount;
+    IMFMediaType *input_type;
+    CRITICAL_SECTION cs;
 };
 
 static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
@@ -91,6 +93,8 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
 
     if (!refcount)
     {
+        transform->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&transform->cs);
         free(transform);
     }
 
@@ -219,9 +223,73 @@ static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface
 
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->input_type)
+        {
+            IMFMediaType_Release(converter->input_type);
+            converter->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->input_type)
+        hr = MFCreateMediaType(&converter->input_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->input_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->input_type);
+        converter->input_type = NULL;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
@@ -337,6 +405,9 @@ HRESULT color_converter_create(REFIID riid, void **ret)
     object->IMFTransform_iface.lpVtbl = &color_converter_vtbl;
     object->refcount = 1;
 
+    InitializeCriticalSection(&object->cs);
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": color_converter_lock");
+
     *ret = &object->IMFTransform_iface;
     return S_OK;
 }
-- 
2.30.2

From 1520936a557f0e76ff39c1dbfec3104a843227e9 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 16:04:31 -0400
Subject: [PATCH 25/40] winegstreamer: Implement ::GetOutputAvailableType for
 color conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 38 +++++++++++++++++++++++++++++--
 1 file changed, 36 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 06186ed7846..6d7064a4482 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -216,9 +216,43 @@ static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface,
 static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_CopyAllItems(converter->input_type, (IMFAttributes *) ret);
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
-- 
2.30.2

From 27268115ba374107f890ecc24c763d1dc78e8d70 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 16:26:28 -0400
Subject: [PATCH 26/40] winegstreamer: Implement ::SetOutputType for color
 conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 99 ++++++++++++++++++++++++++++++-
 1 file changed, 97 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 6d7064a4482..e001c6c827e 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -49,6 +49,7 @@ struct color_converter
     IMFTransform IMFTransform_iface;
     LONG refcount;
     IMFMediaType *input_type;
+    IMFMediaType *output_type;
     CRITICAL_SECTION cs;
 };
 
@@ -95,6 +96,8 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
         free(transform);
     }
 
@@ -258,6 +261,7 @@ static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface
 static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
     unsigned int i;
     HRESULT hr;
@@ -302,6 +306,19 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
     if (i == ARRAY_SIZE(raw_types))
         return MF_E_INVALIDTYPE;
 
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->output_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -328,9 +345,87 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->output_type)
+        {
+            IMFMediaType_Release(converter->output_type);
+            converter->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->input_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->output_type)
+        hr = MFCreateMediaType(&converter->output_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->output_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->output_type);
+        converter->output_type = NULL;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
-- 
2.30.2

From 227ba551bdf8ca8d64f9a7c900121bb7203b1fee Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 16:49:13 -0400
Subject: [PATCH 27/40] winegstreamer: Implement ::Process(Input/Output) for
 color conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 279 +++++++++++++++++++++++++++++-
 1 file changed, 274 insertions(+), 5 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index e001c6c827e..a543b9d77af 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -51,6 +51,10 @@ struct color_converter
     IMFMediaType *input_type;
     IMFMediaType *output_type;
     CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
 };
 
 static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
@@ -98,6 +102,10 @@ static ULONG WINAPI color_converter_Release(IMFTransform *iface)
         DeleteCriticalSection(&transform->cs);
         if (transform->output_type)
             IMFMediaType_Release(transform->output_type);
+        if (transform->stream)
+            unix_funcs->wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            unix_funcs->wg_parser_destroy(transform->parser);
         free(transform);
     }
 
@@ -263,6 +271,7 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
     UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
+    struct wg_format format;
     unsigned int i;
     HRESULT hr;
 
@@ -280,6 +289,11 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
         if (converter->input_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->input_type);
             converter->input_type = NULL;
         }
@@ -319,6 +333,10 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
 
     LeaveCriticalSection(&converter->cs);
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -338,6 +356,21 @@ static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id
         converter->input_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -348,6 +381,7 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
     struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
     UINT64 input_framesize, output_framesize;
     GUID major_type, subtype;
+    struct wg_format format;
     unsigned int i;
     HRESULT hr;
 
@@ -365,6 +399,11 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
 
         if (converter->output_type)
         {
+            if (converter->stream)
+            {
+                unix_funcs->wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->output_type);
             converter->output_type = NULL;
         }
@@ -404,6 +443,10 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
 
     LeaveCriticalSection(&converter->cs);
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -423,9 +466,24 @@ static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD i
         converter->output_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        unix_funcs->wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = unix_funcs->wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = unix_funcs->wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
-    return S_OK;
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
@@ -479,17 +537,221 @@ static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
 static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    void *data;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+            continue;
+
+        memcpy(data, buffer_data, min(buffer_size, size));
+
+        unix_funcs->wg_parser_complete_read_request(converter->parser, WG_READ_SUCCESS, buffer_size);
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI color_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    IMFMediaBuffer *buffer = NULL;
+    struct wg_parser_event event;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    for (;;)
+    {
+        unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+        switch (event.type)
+        {
+            case WG_PARSER_EVENT_BUFFER:
+                break;
+
+            case WG_PARSER_EVENT_SEGMENT:
+                continue;
+
+            default:
+                WARN("Unexpected event, %u\n", event.type);
+                continue;
+        }
+        break;
+    }
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(event.u.buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < event.u.buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, event.u.buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, event.u.buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!unix_funcs->wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, event.u.buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (FAILED(hr) && allocated_sample)
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static const IMFTransformVtbl color_converter_vtbl =
@@ -537,6 +799,13 @@ HRESULT color_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": color_converter_lock");
 
+    if (!(object->parser = unix_funcs->wg_raw_media_converter_create()))
+    {
+        ERR("Failed to create video converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
     *ret = &object->IMFTransform_iface;
     return S_OK;
 }
-- 
2.30.2

From ff86a0db8bfa392206785f7bad239496d743774f Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 16:50:47 -0400
Subject: [PATCH 28/40] winegstreamer: Implement ::ProcessMessage for color
 conversion MFT.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index a543b9d77af..8d2f7a7d643 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -530,9 +530,17 @@ static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %u %lu.\n", iface, message, param);
+    TRACE("%p, %u %lu.\n", iface, message, param);
 
-    return E_NOTIMPL;
+    switch(message)
+    {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+            return S_OK;
+        default:
+            FIXME("Unhandled message type %x.\n", message);
+            return E_NOTIMPL;
+    }
 }
 
 static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
-- 
2.30.2

From 60bb6fb7a36b0e6c8383223ca9c3377ef6b34c05 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 17 Mar 2021 17:01:11 -0400
Subject: [PATCH 29/40] winegstreamer: Implement ::Get(Input/Output)StreamInfo
 for color conversion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/colorconvert.c | 64 +++++++++++++++++++++++++++++--
 1 file changed, 60 insertions(+), 4 deletions(-)

diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 8d2f7a7d643..6f3723b2b1e 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -141,16 +141,72 @@ static HRESULT WINAPI color_converter_GetStreamIDs(IMFTransform *iface, DWORD in
 
 static HRESULT WINAPI color_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->input_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired input buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p %u %p.\n", iface, id, info);
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->output_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired output buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI color_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
-- 
2.30.2

From a058563897065a8603c81e277cd583a373c530af Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 13:53:05 -0400
Subject: [PATCH 30/40] mf/session: Prefer transform-provided sample path.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/mf/session.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 942212d5bf2..a91373b89cd 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -2730,7 +2730,7 @@ static HRESULT transform_node_pull_samples(const struct media_session *session,
         if (FAILED(hr = IMFTransform_GetOutputStreamInfo(node->object.transform, buffers[i].dwStreamID, &stream_info)))
             break;
 
-        if (!(stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES))
+        if (!(stream_info.dwFlags & (MFT_OUTPUT_STREAM_PROVIDES_SAMPLES | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))
         {
             if (FAILED(hr = transform_get_external_output_sample(session, node, i, &stream_info, &buffers[i].pSample)))
                 break;
-- 
2.30.2

From 9c12ed68dd94908c537be13a5fca309fc5472fd6 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 13:53:42 -0400
Subject: [PATCH 31/40] mf/topology: Forward failure from ::SetOutputType when
 resolving topology.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/mf/topology.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/dlls/mf/topology.c b/dlls/mf/topology.c
index 58639a67bdb..60f5f7196b6 100644
--- a/dlls/mf/topology.c
+++ b/dlls/mf/topology.c
@@ -2123,8 +2123,7 @@ static HRESULT connect_to_sink(struct transform_output_type *output_type, struct
     hr = IMFMediaTypeHandler_SetCurrentMediaType(context->sink_handler, output_type->type);
     if (SUCCEEDED(hr))
         hr = IMFTransform_SetOutputType(output_type->transform, 0, output_type->type, 0);
-
-    return S_OK;
+    return hr;
 }
 
 static HRESULT connect_to_converter(struct transform_output_type *output_type, struct connect_context *context)
-- 
2.30.2

From 53a282863094c02b7c033455638058641afcbfd5 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 14:53:49 -0400
Subject: [PATCH 32/40] winegstreamer: Handle flush command in audio
 converstion transform.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/audioconvert.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 43fe8b04e64..1584fefe577 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -618,6 +618,7 @@ static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
     switch(message)
     {
+        case MFT_MESSAGE_COMMAND_FLUSH:
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
-- 
2.30.2

From e3b827cfed8773cb10d49fb690bfa6f3e1f3d02f Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 4 Dec 2020 16:17:11 -0500
Subject: [PATCH 33/40] winegstreamer: In the default configuration, select one
 stream of each major type.

---
 dlls/winegstreamer/media_source.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 14fcac235b0..5398ec469b5 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1066,6 +1066,7 @@ static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
 
 static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
 {
+    BOOL video_selected = FALSE, audio_selected = FALSE;
     IMFStreamDescriptor **descriptors = NULL;
     struct media_source *object;
     UINT64 total_pres_time = 0;
@@ -1159,9 +1160,28 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     if (FAILED(hr = MFCreatePresentationDescriptor(object->stream_count, descriptors, &object->pres_desc)))
         goto fail;
 
+    /* Select one of each major type. */
     for (i = 0; i < object->stream_count; i++)
     {
-        IMFPresentationDescriptor_SelectStream(object->pres_desc, i);
+        IMFMediaTypeHandler *handler;
+        GUID major_type;
+        BOOL select_stream = FALSE;
+
+        IMFStreamDescriptor_GetMediaTypeHandler(descriptors[i], &handler);
+        IMFMediaTypeHandler_GetMajorType(handler, &major_type);
+        if (IsEqualGUID(&major_type, &MFMediaType_Video) && !video_selected)
+        {
+            select_stream = TRUE;
+            video_selected = TRUE;
+        }
+        if (IsEqualGUID(&major_type, &MFMediaType_Audio) && !audio_selected)
+        {
+            select_stream = TRUE;
+            audio_selected = TRUE;
+        }
+        if (select_stream)
+            IMFPresentationDescriptor_SelectStream(object->pres_desc, i);
+        IMFMediaTypeHandler_Release(handler);
         IMFStreamDescriptor_Release(descriptors[i]);
     }
     free(descriptors);
-- 
2.30.2

From b6678515d5860bea8f99ef5bd0f0f929bc780c6a Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 15:25:17 -0400
Subject: [PATCH 34/40] winegstreamer: Implement MF_SD_LANGUAGE.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/gst_private.h  |  1 +
 dlls/winegstreamer/media_source.c | 20 +++++++++++++++++++-
 dlls/winegstreamer/wg_parser.c    | 27 +++++++++++++++++++++++++++
 3 files changed, 47 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 0827f70112f..f616b8a5d9d 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -240,6 +240,7 @@ struct unix_funcs
 
     /* Returns the duration in 100-nanosecond units. */
     uint64_t (CDECL *wg_parser_stream_get_duration)(struct wg_parser_stream *stream);
+    char * (CDECL *wg_parser_stream_get_language)(struct wg_parser_stream *stream);
     /* start_pos and stop_pos are in 100-nanosecond units. */
     bool (CDECL *wg_parser_stream_seek)(struct wg_parser_stream *stream, double rate,
             uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags);
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index 5398ec469b5..c494b5d9c08 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -1154,7 +1154,25 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     descriptors = malloc(object->stream_count * sizeof(IMFStreamDescriptor *));
     for (i = 0; i < object->stream_count; i++)
     {
-        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, &descriptors[object->stream_count - 1 - i]);
+        IMFStreamDescriptor **descriptor = &descriptors[object->stream_count - 1 - i];
+        DWORD language_len;
+        WCHAR *languageW;
+        char *language;
+
+        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, descriptor);
+
+        if ((language = unix_funcs->wg_parser_stream_get_language(object->streams[i]->wg_stream)))
+        {
+            if ((language_len = MultiByteToWideChar(CP_UTF8, 0, language, -1, NULL, 0)))
+            {
+                languageW = malloc(language_len * sizeof(WCHAR));
+                if (MultiByteToWideChar(CP_UTF8, 0, language, -1, languageW, language_len))
+                {
+                    IMFStreamDescriptor_SetString(*descriptor, &MF_SD_LANGUAGE, languageW);
+                }
+                free(languageW);
+            }
+        }
     }
 
     if (FAILED(hr = MFCreatePresentationDescriptor(object->stream_count, descriptors, &object->pres_desc)))
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 394a0d65aeb..dd32b3877af 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -92,6 +92,7 @@ struct wg_parser_stream
     bool flushing, eos, enabled, has_caps;
 
     uint64_t duration;
+    gchar *language_code;
 };
 
 static enum wg_audio_format wg_audio_format_from_gst(GstAudioFormat format)
@@ -845,6 +846,11 @@ static uint64_t CDECL wg_parser_stream_get_duration(struct wg_parser_stream *str
     return stream->duration;
 }
 
+static char * CDECL wg_parser_stream_get_language(struct wg_parser_stream *stream)
+{
+    return stream->language_code;
+}
+
 static bool CDECL wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
         uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags)
 {
@@ -1912,6 +1918,22 @@ static LONGLONG query_duration(GstPad *pad)
     return 0;
 }
 
+static gchar *query_language(GstPad *pad)
+{
+    GstTagList *tag_list;
+    GstEvent *tag_event;
+    gchar *ret = NULL;
+
+    if ((tag_event = gst_pad_get_sticky_event(pad, GST_EVENT_TAG, 0)))
+    {
+        gst_event_parse_tag(tag_event, &tag_list);
+        gst_tag_list_get_string(tag_list, "language-code", &ret);
+        gst_event_unref(tag_event);
+    }
+
+    return ret;
+}
+
 static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
 {
     GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("wine_src",
@@ -1962,6 +1984,7 @@ static HRESULT CDECL wg_parser_connect(struct wg_parser *parser, uint64_t file_s
         struct wg_parser_stream *stream = parser->streams[i];
 
         stream->duration = query_duration(stream->their_src);
+        stream->language_code = query_language(stream->their_src);
         while (!stream->has_caps && !parser->error)
             pthread_cond_wait(&parser->init_cond, &parser->mutex);
         if (parser->error)
@@ -2035,6 +2058,9 @@ static void free_stream(struct wg_parser_stream *stream)
     pthread_cond_destroy(&stream->event_cond);
     pthread_cond_destroy(&stream->event_empty_cond);
 
+    if (stream->language_code)
+        g_free(stream->language_code);
+
     free(stream);
 }
 
@@ -2484,6 +2510,7 @@ static const struct unix_funcs funcs =
     wg_parser_stream_notify_qos,
 
     wg_parser_stream_get_duration,
+    wg_parser_stream_get_language,
     wg_parser_stream_seek,
     wg_parser_stream_drain,
 };
-- 
2.30.2

From 46673f7cca6ceb462cb74ab2ea0194edcf9f8e7d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 15:29:21 -0400
Subject: [PATCH 35/40] winegstreamer: Ensure that the source reports both PCM
 and floating point audio formats.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/media_source.c | 38 +++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index c494b5d9c08..e1c89adcb92 100644
--- a/dlls/winegstreamer/media_source.c
+++ b/dlls/winegstreamer/media_source.c
@@ -788,6 +788,44 @@ static HRESULT media_stream_init_desc(struct media_stream *stream)
                 goto done;
         }
     }
+    else if (format.major_type == WG_MAJOR_TYPE_AUDIO)
+    {
+        /* Make sure to expose both a F32 and PCM type for the source reader to pick from */
+
+        stream_types = malloc( sizeof(IMFMediaType *) * 2 );
+
+        stream_types[0] = mf_media_type_from_wg_format(&format);
+        if (stream_types[0])
+        {
+            GUID base_subtype;
+            UINT32 sample_rate, channel_count, channel_mask;
+
+            IMFMediaType_GetGUID(stream_types[0], &MF_MT_SUBTYPE, &base_subtype);
+            IMFMediaType_GetUINT32(stream_types[0], &MF_MT_AUDIO_SAMPLES_PER_SECOND, &sample_rate);
+            IMFMediaType_GetUINT32(stream_types[0], &MF_MT_AUDIO_NUM_CHANNELS, &channel_count);
+            IMFMediaType_GetUINT32(stream_types[0], &MF_MT_AUDIO_CHANNEL_MASK, &channel_mask);
+
+            MFCreateMediaType(&stream_types[1]);
+            IMFMediaType_SetGUID(stream_types[1], &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_NUM_CHANNELS, channel_count);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_CHANNEL_MASK, channel_mask);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+
+            /* regardless of which format is used in the base type, when the non base-type is used
+               we'd be converting either to or from a floating point type, which has 32 bits per sample */
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_BITS_PER_SAMPLE, 32);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_BLOCK_ALIGNMENT, channel_count * 32 / 8);
+            IMFMediaType_SetUINT32(stream_types[1], &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * channel_count * 32 / 8);
+
+            if (IsEqualGUID(&base_subtype, &MFAudioFormat_Float))
+                IMFMediaType_SetGUID(stream_types[1], &MF_MT_SUBTYPE, &MFAudioFormat_PCM);
+            else
+                IMFMediaType_SetGUID(stream_types[1], &MF_MT_SUBTYPE, &MFAudioFormat_Float);
+
+            type_count = 2;
+        }
+    }
     else
     {
         stream_type = mf_media_type_from_wg_format(&format);
-- 
2.30.2

From 825307a3c7dbf751fc280458fb9e6a2a7961e054 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 16:20:50 -0400
Subject: [PATCH 36/40] winegstreamer: Only require videobox element for parser
 when needed.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/wg_parser.c | 42 ++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 10 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index dd32b3877af..b40193005d1 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -750,6 +750,15 @@ static void CDECL wg_parser_stream_enable(struct wg_parser_stream *stream, const
 
         if (aperture)
         {
+            if (!stream->box && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                return;
+            }
+
             if (aperture->left)
                 g_object_set(G_OBJECT(stream->box), "left", -aperture->left, NULL);
             if (aperture->top)
@@ -1275,12 +1284,7 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
             goto out;
         }
 
-        if (!(videobox = gst_element_factory_make("videobox", NULL)))
-        {
-            fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"base\" plugins installed?\n",
-                    8 * (int)sizeof(void *));
-            goto out;
-        }
+        videobox = gst_element_factory_make("videobox", NULL);
 
         /* videoflip does not support 15 and 16-bit RGB so add a second videoconvert
          * to do the final conversion. */
@@ -1293,6 +1297,14 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
 
         if (!parser->seekable)
         {
+            if (!videobox && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                goto out;
+            }
             if (stream->aperture.left)
                 g_object_set(G_OBJECT(videobox), "left", -stream->aperture.left, NULL);
             if (stream->aperture.bottom)
@@ -1310,15 +1322,25 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
         gst_element_sync_state_with_parent(vconv);
         gst_bin_add(GST_BIN(parser->container), flip);
         gst_element_sync_state_with_parent(flip);
-        gst_bin_add(GST_BIN(parser->container), videobox);
-        gst_element_sync_state_with_parent(videobox);
+        if (videobox)
+        {
+            gst_bin_add(GST_BIN(parser->container), videobox);
+            gst_element_sync_state_with_parent(videobox);
+        }
         gst_bin_add(GST_BIN(parser->container), vconv2);
         gst_element_sync_state_with_parent(vconv2);
 
         gst_element_link(deinterlace, vconv);
         gst_element_link(vconv, flip);
-        gst_element_link(flip, videobox);
-        gst_element_link(videobox, vconv2);
+        if (videobox)
+        {
+            gst_element_link(flip, videobox);
+            gst_element_link(videobox, vconv2);
+        }
+        else
+        {
+            gst_element_link(flip, vconv2);
+        }
 
         stream->post_sink = gst_element_get_static_pad(deinterlace, "sink");
         stream->post_src = gst_element_get_static_pad(vconv2, "src");
-- 
2.30.2

From e3590fcb5bd8ceb73977ea450fceefe922ecd1b0 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 18 Mar 2021 16:54:44 -0400
Subject: [PATCH 37/40] mfplat: Stub out MFCreateDXGIDeviceManager, to avoid
 the d3d path.

---
 dlls/mfplat/main.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 999d8a86147..70745466593 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -8902,6 +8902,8 @@ HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **man
 
     TRACE("%p, %p.\n", token, manager);
 
+    return E_NOTIMPL;
+
     if (!token || !manager)
         return E_POINTER;
 
-- 
2.30.2

From 74f743abaf29d774edc3b1285f0f1988b7c0ca0d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Fri, 19 Mar 2021 16:30:01 -0400
Subject: [PATCH 38/40] Revert "mfreadwrite/reader: Alternate between selected
 streams for MF_SOURCE_READER_ANY_STREAM requests."

This reverts commit 1fceb1213992b79aa7f1a5dc0a72ab3756ee524d.
---
 dlls/mfreadwrite/reader.c       | 68 +++++++++++++++++++--------------
 dlls/mfreadwrite/tests/mfplat.c | 10 +++--
 2 files changed, 46 insertions(+), 32 deletions(-)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index ab959c26165..d209596b546 100644
--- a/dlls/mfreadwrite/reader.c
+++ b/dlls/mfreadwrite/reader.c
@@ -103,6 +103,7 @@ enum media_stream_flags
     STREAM_FLAG_SAMPLE_REQUESTED = 0x1, /* Protects from making multiple sample requests. */
     STREAM_FLAG_SELECTED = 0x2,         /* Mirrors descriptor, used to simplify tests when starting the source. */
     STREAM_FLAG_PRESENTED = 0x4,        /* Set if stream was selected last time Start() was called. */
+    STREAM_FLAG_REQUESTED_ONCE = 0x8,   /* Used for MF_SOURCE_READER_ANY_STREAM in synchronous mode. */
 };
 
 struct media_stream
@@ -112,7 +113,7 @@ struct media_stream
     IMFTransform *decoder;
     IMFVideoSampleAllocatorEx *allocator;
     IMFVideoSampleAllocatorNotify notify_cb;
-    unsigned int id;
+    DWORD id;
     unsigned int index;
     enum media_stream_state state;
     unsigned int flags;
@@ -181,16 +182,15 @@ struct source_reader
     LONG refcount;
     IMFMediaSource *source;
     IMFPresentationDescriptor *descriptor;
+    DWORD first_audio_stream_index;
+    DWORD first_video_stream_index;
     IMFSourceReaderCallback *async_callback;
     IMFAttributes *attributes;
     IUnknown *device_manager;
-    unsigned int first_audio_stream_index;
-    unsigned int first_video_stream_index;
-    unsigned int last_read_index;
-    unsigned int stream_count;
     unsigned int flags;
     enum media_source_state source_state;
     struct media_stream *streams;
+    DWORD stream_count;
     struct list responses;
     CRITICAL_SECTION cs;
     CONDITION_VARIABLE sample_event;
@@ -473,7 +473,7 @@ static HRESULT source_reader_request_sample(struct source_reader *reader, struct
             WARN("Sample request failed, hr %#x.\n", hr);
         else
         {
-            stream->flags |= STREAM_FLAG_SAMPLE_REQUESTED;
+            stream->flags |= (STREAM_FLAG_SAMPLE_REQUESTED | STREAM_FLAG_REQUESTED_ONCE);
         }
     }
 
@@ -1074,42 +1074,39 @@ static BOOL source_reader_get_read_result(struct source_reader *reader, struct m
     return !request_sample;
 }
 
-static HRESULT source_reader_get_next_selected_stream(struct source_reader *reader, unsigned int *stream_index)
+static HRESULT source_reader_get_first_selected_stream(struct source_reader *reader, unsigned int flags,
+        unsigned int *stream_index)
 {
-    unsigned int i, start_idx, stop_idx, first_selected = ~0u, requests = ~0u;
+    unsigned int i, first_selected = ~0u;
     BOOL selected, stream_drained;
 
-    start_idx = (reader->last_read_index + 1) % reader->stream_count;
-    stop_idx = reader->last_read_index == ~0u ? reader->stream_count : reader->last_read_index;
-
-    for (i = start_idx; i < reader->stream_count && i != stop_idx; i = (i + 1) % (reader->stream_count + 1))
+    for (i = 0; i < reader->stream_count; ++i)
     {
         stream_drained = reader->streams[i].state == STREAM_STATE_EOS && !reader->streams[i].responses;
         selected = SUCCEEDED(source_reader_get_stream_selection(reader, i, &selected)) && selected;
 
-        if (selected)
+        if (selected && !(reader->streams[i].flags & flags))
         {
             if (first_selected == ~0u)
                 first_selected = i;
 
-            /* Try to balance pending reads. */
-            if (!stream_drained && reader->streams[i].requests < requests)
+            if (!stream_drained)
             {
-                requests = reader->streams[i].requests;
                 *stream_index = i;
+                break;
             }
         }
     }
 
-    /* If all selected streams reached EOS, use first selected. */
-    if (first_selected != ~0u)
+    /* If all selected streams reached EOS, use first selected. This fallback only applies after reader went through all
+       selected streams once. */
+    if (i == reader->stream_count && first_selected != ~0u && !flags)
     {
-        if (requests == ~0u)
-            *stream_index = first_selected;
-        reader->last_read_index = *stream_index;
+        *stream_index = first_selected;
+        i = first_selected;
     }
 
-    return first_selected == ~0u ? MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED : S_OK;
+    return i == reader->stream_count ? MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED : S_OK;
 }
 
 static HRESULT source_reader_get_stream_read_index(struct source_reader *reader, unsigned int index, unsigned int *stream_index)
@@ -1126,7 +1123,18 @@ static HRESULT source_reader_get_stream_read_index(struct source_reader *reader,
             *stream_index = reader->first_audio_stream_index;
             break;
         case MF_SOURCE_READER_ANY_STREAM:
-            return source_reader_get_next_selected_stream(reader, stream_index);
+            if (reader->async_callback)
+            {
+                /* Pick first selected stream. */
+                hr = source_reader_get_first_selected_stream(reader, 0, stream_index);
+            }
+            else
+            {
+                /* Cycle through all selected streams once, next pick first selected. */
+                if (FAILED(hr = source_reader_get_first_selected_stream(reader, STREAM_FLAG_REQUESTED_ONCE, stream_index)))
+                    hr = source_reader_get_first_selected_stream(reader, 0, stream_index);
+            }
+            return hr;
         default:
             *stream_index = index;
     }
@@ -1433,7 +1441,8 @@ static HRESULT WINAPI src_reader_SetStreamSelection(IMFSourceReader *iface, DWOR
             if (!selection_changed)
             {
                 source_reader_get_stream_selection(reader, i, &selected);
-                selection_changed = !!(selected ^ selection);
+                if (selected ^ selection)
+                    selection_changed = TRUE;
             }
 
             if (selection)
@@ -1457,7 +1466,8 @@ static HRESULT WINAPI src_reader_SetStreamSelection(IMFSourceReader *iface, DWOR
         }
 
         source_reader_get_stream_selection(reader, index, &selected);
-        selection_changed = !!(selected ^ selection);
+        if (selected ^ selection)
+            selection_changed = TRUE;
 
         if (selection)
             hr = IMFPresentationDescriptor_SelectStream(reader->descriptor, index);
@@ -1465,8 +1475,11 @@ static HRESULT WINAPI src_reader_SetStreamSelection(IMFSourceReader *iface, DWOR
             hr = IMFPresentationDescriptor_DeselectStream(reader->descriptor, index);
     }
 
-    if (selection_changed)
-        reader->last_read_index = ~0u;
+    if (SUCCEEDED(hr) && selection_changed)
+    {
+        for (i = 0; i < reader->stream_count; ++i)
+            reader->streams[i].flags &= ~STREAM_FLAG_REQUESTED_ONCE;
+    }
 
     LeaveCriticalSection(&reader->cs);
 
@@ -2351,7 +2364,6 @@ static HRESULT create_source_reader_from_source(IMFMediaSource *source, IMFAttri
     /* At least one major type has to be set. */
     object->first_audio_stream_index = reader_get_first_stream_index(object->descriptor, &MFMediaType_Audio);
     object->first_video_stream_index = reader_get_first_stream_index(object->descriptor, &MFMediaType_Video);
-    object->last_read_index = ~0u;
 
     if (object->first_audio_stream_index == MF_SOURCE_READER_INVALID_STREAM_INDEX &&
             object->first_video_stream_index == MF_SOURCE_READER_INVALID_STREAM_INDEX)
diff --git a/dlls/mfreadwrite/tests/mfplat.c b/dlls/mfreadwrite/tests/mfplat.c
index c6191767164..353868b6af1 100644
--- a/dlls/mfreadwrite/tests/mfplat.c
+++ b/dlls/mfreadwrite/tests/mfplat.c
@@ -931,12 +931,13 @@ static void test_source_reader_from_media_source(void)
     hr = IMFSourceReader_SetStreamSelection(reader, 2, TRUE);
     ok(hr == S_OK, "Failed to select a stream, hr %#x.\n", hr);
 
-    for (i = 0; i < TEST_SOURCE_NUM_STREAMS + 1; ++i)
+    for (i = 0; i < 2 * TEST_SOURCE_NUM_STREAMS; ++i)
     {
         hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_ANY_STREAM, 0, &actual_index, &stream_flags,
                 &timestamp, &sample);
         ok(hr == S_OK, "Failed to get a sample, hr %#x.\n", hr);
-        ok(actual_index == i % TEST_SOURCE_NUM_STREAMS, "%d: Unexpected stream index %u\n", i, actual_index);
+        ok(actual_index == (i < TEST_SOURCE_NUM_STREAMS ? i : 0), "%d: Unexpected stream index %u\n",
+                i, actual_index);
         ok(!stream_flags, "Unexpected stream flags %#x.\n", stream_flags);
         ok(timestamp == 123, "Unexpected timestamp.\n");
         ok(!!sample, "Expected sample object.\n");
@@ -949,12 +950,13 @@ static void test_source_reader_from_media_source(void)
     hr = IMFSourceReader_SetStreamSelection(reader, 0, TRUE);
     ok(hr == S_OK, "Failed to select a stream, hr %#x.\n", hr);
 
-    for (i = 0; i < TEST_SOURCE_NUM_STREAMS + 1; ++i)
+    for (i = 0; i < 2 * TEST_SOURCE_NUM_STREAMS; ++i)
     {
         hr = IMFSourceReader_ReadSample(reader, MF_SOURCE_READER_ANY_STREAM, 0, &actual_index, &stream_flags,
                 &timestamp, &sample);
         ok(hr == S_OK, "Failed to get a sample, hr %#x.\n", hr);
-        ok(actual_index == i % TEST_SOURCE_NUM_STREAMS, "%d: Unexpected stream index %u\n", i, actual_index);
+        ok(actual_index == (i < TEST_SOURCE_NUM_STREAMS ? i : 0), "%d: Unexpected stream index %u\n",
+                i, actual_index);
         ok(!stream_flags, "Unexpected stream flags %#x.\n", stream_flags);
         ok(timestamp == 123, "Unexpected timestamp.\n");
         ok(!!sample, "Expected sample object.\n");
-- 
2.30.2

From 7a4416fff1b39d627cf31a17d3e3297ff8b3fd4b Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 22 Mar 2021 15:50:29 -0400
Subject: [PATCH 39/40] winegstreamer: Don't rely on max_size in unseekable
 parser.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/wg_parser.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index b40193005d1..5f95b12dc6e 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -1643,9 +1643,9 @@ static void *push_data(void *arg)
         ULONG size;
         int ret;
 
-        if (parser->next_offset >= max_size)
+        if (parser->seekable && parser->next_offset >= max_size)
             break;
-        size = min(alloc_size, max_size - parser->next_offset);
+        size = parser->seekable ? min(alloc_size, max_size - parser->next_offset) : alloc_size;
 
         ret = pull_data(parser, parser->next_offset, size, &size, &buffer);
 
-- 
2.30.2

From e8bfab097802af8acafc7cb1dec7aebe9db7eeac Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Mon, 22 Mar 2021 15:50:51 -0400
Subject: [PATCH 40/40] winegstreamer: Implement MFT_MESSAGE_COMMAND_FLUSH for
 media converters.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winegstreamer/audioconvert.c | 20 ++++++++++++++++++++
 dlls/winegstreamer/colorconvert.c | 23 +++++++++++++++++++++++
 2 files changed, 43 insertions(+)

diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index 1584fefe577..df471122b9e 100644
--- a/dlls/winegstreamer/audioconvert.c
+++ b/dlls/winegstreamer/audioconvert.c
@@ -614,11 +614,31 @@ static HRESULT WINAPI audio_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    struct wg_parser_event event;
+
     TRACE("%p, %u %lu.\n", iface, message, param);
 
     switch(message)
     {
         case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            while (event.type != WG_PARSER_EVENT_BUFFER)
+                unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+            unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
index 6f3723b2b1e..947ef9adacb 100644
--- a/dlls/winegstreamer/colorconvert.c
+++ b/dlls/winegstreamer/colorconvert.c
@@ -586,11 +586,31 @@ static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id
 
 static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    struct wg_parser_event event;
+
     TRACE("%p, %u %lu.\n", iface, message, param);
 
     switch(message)
     {
         case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            while (event.type != WG_PARSER_EVENT_BUFFER)
+                unix_funcs->wg_parser_stream_get_event(converter->stream, &event);
+
+            unix_funcs->wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
@@ -641,7 +661,10 @@ static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id
     for (;;)
     {
         if (!unix_funcs->wg_parser_get_read_request(converter->parser, &data, &offset, &size))
+        {
+            TRACE("sink unconnected\n");
             continue;
+        }
 
         memcpy(data, buffer_data, min(buffer_size, size));
 
-- 
2.30.2

